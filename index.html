<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÂØπËØùÂä©Êâã</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .main-container {
            display: flex;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
            height: 700px;
        }
        
        .sidebar {
            width: 300px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow-y: auto;
        }
        
        .sidebar h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 16px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        
        .prompt-section {
            margin-bottom: 20px;
        }
        
        .prompt-label {
            font-size: 13px;
            color: #666;
            margin-bottom: 8px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            resize: vertical;
            min-height: 100px;
            transition: border-color 0.3s;
        }
        
        textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .preset-prompts {
            margin-top: 15px;
        }
        
        .preset-btn {
            width: 100%;
            padding: 8px;
            margin-bottom: 8px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            color: #333;
            transition: all 0.3s;
        }
        
        .preset-btn:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
        
        .container {
            flex: 1;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        }
        
        .header {
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px 12px 0 0;
            text-align: center;
        }
        
        .header h1 {
            font-size: 24px;
            margin-bottom: 5px;
        }
        
        .header p {
            font-size: 14px;
            opacity: 0.9;
        }
        
        .chat-box {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .message {
            margin-bottom: 15px;
            display: flex;
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .message.user {
            justify-content: flex-end;
        }
        
        .message.ai {
            justify-content: flex-start;
        }
        
        .message-content {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 8px;
            word-wrap: break-word;
            line-height: 1.6;
            white-space: pre-wrap;
        }
        
        .message.user .message-content {
            background: #667eea;
            color: white;
            border-bottom-right-radius: 2px;
        }
        
        .message.ai .message-content {
            background: white;
            color: #333;
            border: 1px solid #e0e0e0;
            border-bottom-left-radius: 2px;
        }
        
        .input-area {
            padding: 20px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 10px;
        }
        
        input[type="text"] {
            flex: 1;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }
        
        button {
            padding: 12px 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #5568d3;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .loading {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #667eea;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
            margin-right: 5px;
        }
        
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        .model-info {
            background: #f0f0f0;
            padding: 10px;
            border-radius: 6px;
            font-size: 12px;
            color: #666;
            margin-bottom: 15px;
            text-align: center;
        }

        .model-info span {
            color: #667eea;
            font-weight: 600;
        }

        .parameter-section {
            margin-bottom: 20px;
        }

        .parameter-group {
            margin-bottom: 15px;
        }

        .parameter-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
        }

        .parameter-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 12px;
            transition: border-color 0.3s;
        }

        .parameter-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .parameter-value {
            color: #667eea;
            font-weight: 600;
        }

        .message-actions {
            display: none;
            font-size: 12px;
            margin-top: 8px;
        }

        .message.user:hover .message-actions {
            display: flex;
            gap: 8px;
        }

        .edit-btn, .delete-btn {
            background: rgba(255, 255, 255, 0.3);
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: background 0.2s;
        }

        .edit-btn:hover, .delete-btn:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .edit-mode {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .edit-input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }

        .edit-btn-small, .cancel-btn-small {
            padding: 6px 12px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .cancel-btn-small {
            background: #999;
        }

        .edit-btn-small:hover {
            background: #5568d3;
        }

        .cancel-btn-small:hover {
            background: #777;
        }

        .message-wrapper {
            position: relative;
            margin-bottom: 15px;
            display: flex;
            animation: slideIn 0.3s ease-out;
        }

        .branch-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            min-width: 30px;
            margin-right: 8px;
            font-size: 12px;
            color: #667eea;
            font-weight: 600;
        }

        .message-content-wrapper {
            flex: 1;
        }

        .branch-info {
            font-size: 10px;
            color: #999;
            margin-top: 4px;
        }

        .branch-panel {
            position: fixed;
            left: 0;
            top: 0;
            width: 280px;
            height: 100vh;
            background: white;
            border-right: 1px solid #ddd;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.1);
            transform: translateX(-280px);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .branch-panel.active {
            transform: translateX(0);
        }

        .branch-panel-header {
            padding: 15px;
            border-bottom: 2px solid #667eea;
            background: #f0f0f0;
            flex-shrink: 0;
        }

        .branch-panel-header h3 {
            margin: 0;
            font-size: 14px;
            color: #333;
        }

        .branch-panel-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #ddd;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .branch-panel-close:hover {
            background: #ccc;
        }

        .branch-tree {
            padding: 10px;
            flex: 1;
            overflow-y: auto;
        }

        .branch-node {
            padding: 8px;
            margin: 4px 0;
            border-left: 3px solid #ddd;
            border-radius: 4px;
            background: #f9f9f9;
            font-size: 12px;
            color: #666;
            transition: all 0.2s;
            word-break: break-word;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .branch-node:hover {
            background: #f0f0f0;
            border-left-color: #667eea;
        }

        .branch-node.active {
            background: #e8ebff;
            border-left-color: #667eea;
            font-weight: 600;
            color: #667eea;
        }

        .branch-node-header {
            display: flex;
            align-items: flex-start;
            cursor: pointer;
            user-select: none;
        }

        .branch-toggle-icon {
            font-size: 10px;
            margin-right: 6px;
            min-width: 12px;
            display: inline-block;
            transition: transform 0.2s;
        }

        .branch-toggle-icon.collapsed {
            transform: rotate(-90deg);
        }

        .branch-node-content {
            flex: 1;
        }

        .branch-node-children {
            margin-left: 12px;
            margin-top: 4px;
            border-left: 1px dashed #ddd;
            padding-left: 8px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .branch-node-children.expanded {
            max-height: 10000px;
        }

        .branch-node-label {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .toggle-branch-btn {
            position: fixed;
            left: 10px;
            bottom: 20px;
            width: 50px;
            height: 50px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 24px;
            z-index: 999;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
            transition: all 0.3s;
        }

        .toggle-branch-btn:hover {
            background: #5568d3;
            transform: scale(1.1);
        }

        .content-overlay {
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            display: none;
            z-index: 999;
        }

        .content-overlay.active {
            display: block;
        }

        .ai-message-actions {
            display: none;
            font-size: 12px;
            margin-top: 8px;
        }

        .message.ai:hover .ai-message-actions {
            display: flex;
            gap: 8px;
        }

        .branch-created-indicator {
            display: inline-block;
            background: #ffa500;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin-left: 4px;
        }

        .data-management {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #ddd;
        }

        .data-management h4 {
            font-size: 12px;
            color: #333;
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .data-btn {
            width: 100%;
            padding: 8px;
            margin-bottom: 6px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            color: #333;
            transition: all 0.3s;
        }

        .data-btn:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .data-btn.danger {
            background: #ffcccc;
            color: #cc0000;
        }

        .data-btn.danger:hover {
            background: #ff6666;
            color: white;
        }

        #fileInput {
            display: none;
        }

        .save-indicator {
            font-size: 10px;
            color: #999;
            text-align: center;
            margin-top: 8px;
            height: 16px;
        }

        .save-indicator.success {
            color: #00aa00;
            font-weight: 600;
        }

        /* ========== ÈÖçÁΩÆ‰∏≠ÂøÉÈù¢ÊùøÊ†∑Âºè ========== */
        .config-center-overlay {
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 2000;
        }

        .config-center-overlay.active {
            display: block;
        }

        .config-center-panel {
            position: fixed;
            right: 0;
            top: 0;
            width: 450px;
            height: 100vh;
            background: white;
            box-shadow: -2px 0 12px rgba(0, 0, 0, 0.3);
            transform: translateX(500px);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
            z-index: 2001;
            overflow: hidden;
        }

        .config-center-panel.active {
            transform: translateX(0);
        }

        .config-panel-header {
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            border-bottom: 2px solid #667eea;
        }

        .config-panel-header h2 {
            margin: 0;
            font-size: 18px;
        }

        .config-panel-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            transition: background 0.2s;
        }

        .config-panel-close:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .config-tabs {
            display: flex;
            gap: 0;
            border-bottom: 1px solid #ddd;
            background: #f5f5f5;
            padding: 0 20px;
            flex-shrink: 0;
            overflow-x: auto;
        }

        .config-tab {
            padding: 12px 16px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 13px;
            color: #666;
            font-weight: 600;
            white-space: nowrap;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .config-tab:hover {
            color: #667eea;
        }

        .config-tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .config-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .config-section {
            display: none;
        }

        .config-section.active {
            display: block;
        }

        .config-item {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            transition: all 0.2s;
        }

        .config-item:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .config-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .config-item-name {
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        .config-item-actions {
            display: flex;
            gap: 6px;
        }

        .config-btn-small {
            padding: 4px 8px;
            font-size: 11px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .config-btn-small:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .config-btn-small.danger {
            background: #ffe0e0;
            color: #cc0000;
        }

        .config-btn-small.danger:hover {
            background: #ff6666;
            color: white;
        }

        .config-item-detail {
            font-size: 12px;
            color: #666;
            margin: 8px 0;
            padding: 8px;
            background: #f9f9f9;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            word-break: break-all;
        }

        .config-form {
            background: #f9f9f9;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 12px;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-group:last-child {
            margin-bottom: 0;
        }

        .form-label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #333;
            margin-bottom: 6px;
            text-transform: uppercase;
        }

        .form-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
            transition: border-color 0.2s;
        }

        .form-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }

        .form-textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            resize: vertical;
            min-height: 80px;
            transition: border-color 0.2s;
        }

        .form-textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }

        .form-buttons {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .form-btn {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .form-btn.primary {
            background: #667eea;
            color: white;
        }

        .form-btn.primary:hover {
            background: #5568d3;
        }

        .form-btn.secondary {
            background: #f0f0f0;
            color: #333;
            border: 1px solid #ddd;
        }

        .form-btn.secondary:hover {
            background: #e0e0e0;
        }

        .toggle-config-btn {
            position: fixed;
            right: 20px;
            bottom: 80px;
            width: 50px;
            height: 50px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 24px;
            z-index: 999;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
            transition: all 0.3s;
        }

        .toggle-config-btn:hover {
            background: #5568d3;
            transform: scale(1.1);
        }

        .toggle-execution-btn {
            position: fixed;
            right: 20px;
            bottom: 140px;
            width: 50px;
            height: 50px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 24px;
            z-index: 999;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
            transition: all 0.3s;
        }

        .toggle-execution-btn:hover {
            background: #5568d3;
            transform: scale(1.1);
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #999;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 12px;
        }

        .chain-connection {
            background: #e8ebff;
            border: 1px solid #667eea;
            padding: 8px;
            border-radius: 4px;
            margin: 8px 0;
            font-size: 12px;
            color: #667eea;
        }

        .chain-info-table {
            width: 100%;
            font-size: 12px;
            margin: 8px 0;
        }

        .chain-info-table tr {
            border-bottom: 1px solid #f0f0f0;
        }

        .chain-info-table td {
            padding: 6px 0;
        }

        .chain-info-table td:first-child {
            color: #999;
            width: 80px;
            font-weight: 600;
        }

        .chain-info-table td:last-child {
            color: #333;
        }

        /* ========== Phase 2: ÈìæÊù°ÊâßË°åÁ≥ªÁªü ========== */
        .execution-panel {
            position: fixed;
            bottom: 0;
            right: 0;
            width: 100%;
            max-width: 600px;
            background: white;
            border-top: 2px solid #667eea;
            border-left: 1px solid #ddd;
            box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.1);
            max-height: 400px;
            overflow-y: auto;
            display: none;
            z-index: 1500;
            padding: 20px;
            box-sizing: border-box;
        }

        .execution-panel.active {
            display: block;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }

        .execution-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .execution-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #999;
        }

        .execution-close:hover {
            color: #333;
        }

        .route-builder {
            background: #f9f9f9;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 12px;
        }

        .route-builder h4 {
            margin: 0 0 12px 0;
            font-size: 13px;
            color: #333;
            font-weight: 600;
        }

        .execution-mode-selector {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin-bottom: 12px;
        }

        .mode-btn {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-size: 11px;
            text-align: center;
            transition: all 0.2s;
        }

        .mode-btn:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .mode-btn.selected {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .chain-selector-group {
            margin-bottom: 12px;
        }

        .chain-selector-label {
            font-size: 11px;
            color: #666;
            font-weight: 600;
            margin-bottom: 6px;
            display: block;
            text-transform: uppercase;
        }

        .chain-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .chain-toggle {
            padding: 6px 10px;
            font-size: 11px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .chain-toggle:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .chain-toggle.selected {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .execution-flow-diagram {
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #333;
            overflow-x: auto;
        }

        .execution-btns {
            display: flex;
            gap: 8px;
        }

        .exec-btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .exec-btn.primary {
            background: #667eea;
            color: white;
        }

        .exec-btn.primary:hover {
            background: #5568d3;
        }

        .exec-btn.secondary {
            background: #f0f0f0;
            color: #333;
            border: 1px solid #ddd;
        }

        .exec-btn.secondary:hover {
            background: #e0e0e0;
        }

        .execution-result {
            margin-top: 15px;
            padding: 12px;
            background: #f9f9f9;
            border-radius: 6px;
            border-left: 3px solid #667eea;
        }

        .execution-result-title {
            font-weight: 600;
            color: #333;
            font-size: 12px;
            margin-bottom: 8px;
        }

        .execution-result-item {
            background: white;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
            font-size: 12px;
        }

        .execution-result-item.chain-result {
            border-left: 3px solid #667eea;
        }

        .execution-result-item.error {
            border-left-color: #ff6666;
            background: #fff0f0;
        }

        .chain-execution-label {
            font-weight: 600;
            color: #667eea;
            font-size: 11px;
            margin-bottom: 4px;
        }

        .chain-execution-text {
            color: #333;
            word-wrap: break-word;
        }

        .execution-stats {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #eee;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-weight: 600;
            color: #667eea;
            font-size: 16px;
        }

        .stat-label {
            font-size: 11px;
            color: #999;
            margin-top: 4px;
        }

        .route-preview {
            display: inline-block;
            padding: 6px 12px;
            background: #e8ebff;
            border: 1px solid #667eea;
            border-radius: 4px;
            font-size: 11px;
            color: #667eea;
            font-family: 'Courier New', monospace;
            margin-top: 8px;
        }

        .execution-spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #667eea;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 0.6s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="content-overlay" id="contentOverlay" onclick="closeBranchPanel()"></div>
    
    <!-- ÂàÜÊîØÈù¢Êùø -->
    <div class="branch-panel" id="branchPanel">
        <div class="branch-panel-header">
            <h3>üå≥ ÂØπËØùÂàÜÊîØ</h3>
            <button class="branch-panel-close" onclick="closeBranchPanel()">‚úï</button>
        </div>
        <div class="branch-tree" id="branchTree"></div>
    </div>
    
    <!-- ÂàáÊç¢ÂàÜÊîØÊåâÈíÆ -->
    <button class="toggle-branch-btn" id="toggleBranchBtn" onclick="toggleBranchPanel()" title="ÂàáÊç¢ÂàÜÊîØËßÜÂõæ">üå≥</button>

    <!-- ÈÖçÁΩÆ‰∏≠ÂøÉ -->
    <div class="config-center-overlay" id="configCenterOverlay" onclick="closeConfigCenter()"></div>
    <div class="config-center-panel" id="configCenterPanel">
        <div class="config-panel-header">
            <h2>‚öôÔ∏è ÈìæÊù°ÈÖçÁΩÆ‰∏≠ÂøÉ</h2>
            <button class="config-panel-close" onclick="closeConfigCenter()">‚úï</button>
        </div>

        <div class="config-tabs">
            <button class="config-tab active" onclick="switchConfigTab('models')">üìã Ê®°Âûã</button>
            <button class="config-tab" onclick="switchConfigTab('prompts')">üìù ÊèêÁ§∫ËØç</button>
            <button class="config-tab" onclick="switchConfigTab('memories')">üß† ËÆ∞ÂøÜÂ∫ì</button>
            <button class="config-tab" onclick="switchConfigTab('chains')">üîó ÈìæÊù°</button>
            <button class="config-tab" onclick="switchConfigTab('paths')">üõ£Ô∏è Ë∑ØÂæÑ</button>
            <button class="config-tab" onclick="switchConfigTab('routes')">üìç Ë∑ØÁî±</button>
        </div>

        <div class="config-content">
            <!-- Ê®°ÂûãÁÆ°ÁêÜ -->
            <div class="config-section active" id="modelsSection"></div>

            <!-- ÊèêÁ§∫ËØçÁÆ°ÁêÜ -->
            <div class="config-section" id="promptsSection"></div>

            <!-- ËÆ∞ÂøÜÂ∫ìÁÆ°ÁêÜ -->
            <div class="config-section" id="memoriesSection"></div>

            <!-- ÈìæÊù°ÁÆ°ÁêÜ -->
            <div class="config-section" id="chainsSection"></div>

            <!-- ÈìæÊù°Ë∑ØÂæÑÁÆ°ÁêÜ -->
            <div class="config-section" id="chainPathsSection"></div>

            <!-- Ë∑ØÁî±ÁÆ°ÁêÜ -->
            <div class="config-section" id="routesSection"></div>
        </div>
    </div>

    <!-- ÂàáÊç¢ÈÖçÁΩÆ‰∏≠ÂøÉÊåâÈíÆ -->
    <button class="toggle-config-btn" id="toggleConfigBtn" onclick="toggleConfigCenter()" title="ÊâìÂºÄÈÖçÁΩÆ‰∏≠ÂøÉ">‚öôÔ∏è</button>

    <!-- ÂàáÊç¢ÈìæÊù°ÊâßË°åÊåâÈíÆ -->
    <button class="toggle-execution-btn" id="toggleExecutionBtn" onclick="toggleExecutionPanel()" title="ÊâìÂºÄÈìæÊù°ÊâßË°å">‚ñ∂Ô∏è</button>

    <!-- ÈìæÊù°ÊâßË°åÈù¢Êùø -->
    <div class="execution-panel" id="executionPanel">
        <div class="execution-header">
            <h3>‚ñ∂Ô∏è ÈìæÊù°ÊâßË°åÁÆ°ÁêÜ</h3>
            <button class="execution-close" onclick="closeExecutionPanel()">‚úï</button>
        </div>

        <div class="route-builder">
            <h4>üéØ ÈÄâÊã©ÊâßË°åÊ®°Âºè</h4>
            <div class="execution-mode-selector">
                <button class="mode-btn" onclick="selectExecutionMode('sequential')">
                    È°∫Â∫è<br/><small>A‚ÜíB‚ÜíC</small>
                </button>
                <button class="mode-btn" onclick="selectExecutionMode('parallel')">
                    Âπ∂Ë°å<br/><small>A//B//C</small>
                </button>
                <button class="mode-btn" onclick="selectExecutionMode('branching')">
                    Ê†ëÂΩ¢<br/><small>A‚Üí{B,C}</small>
                </button>
            </div>

            <div class="chain-selector-group">
                <label class="chain-selector-label">üìå ÈÄâÊã©ÈìæÊù°</label>
                <div class="chain-selector" id="chainSelectorContainer"></div>
            </div>

            <div class="execution-flow-diagram" id="executionFlowDiagram">
                - ÈÄâÊã©ÊâßË°åÊ®°ÂºèÂíåÈìæÊù°ÂêéÊòæÁ§∫ÊµÅÁ®ãÂõæ -
            </div>

            <div class="execution-btns">
                <button class="exec-btn primary" onclick="executeRoute()">‚ñ∂Ô∏è ÊâßË°åË∑ØÁî±</button>
                <button class="exec-btn secondary" onclick="saveAsRoute()">üíæ ‰øùÂ≠ò‰∏∫Ë∑ØÁî±</button>
            </div>
        </div>

        <div id="executionResultContainer"></div>
    </div>

    <div class="main-container">
        <!-- ‰æßËæπÊ†è -->
        <div class="sidebar">
            <h3>‚öôÔ∏è ËÆæÁΩÆ</h3>
            
            <div class="model-info">
                Ê®°Âûã: <span id="modelName">my-local-model</span>
            </div>
            
            <div class="prompt-section">
                <div class="prompt-label">Á≥ªÁªüÊèêÁ§∫ËØç</div>
                <textarea id="systemPrompt" placeholder="ËæìÂÖ•Á≥ªÁªüÁ∫ßÊèêÁ§∫ËØçÔºåÁî®‰∫éÊåáÂØºAIÁöÑË°å‰∏∫...">‰Ω†ÊòØ‰∏Ä‰∏™ÊúâÁî®ÁöÑAIÂä©Êâã„ÄÇËØ∑Áî®‰∏≠ÊñáÂõûÁ≠îÈóÆÈ¢ò„ÄÇ</textarea>
            </div>

            <div class="parameter-section">
                <div class="prompt-label">üéöÔ∏è ÁîüÊàêÂèÇÊï∞</div>
                
                <div class="parameter-group">
                    <div class="parameter-label">
                        <span>Ê∏©Â∫¶ (Temperature)</span>
                        <span class="parameter-value" id="tempValue">0.7</span>
                    </div>
                    <input 
                        type="range" 
                        id="temperature" 
                        class="parameter-input" 
                        min="0" 
                        max="2" 
                        step="0.1" 
                        value="0.7"
                        style="padding: 0; height: 6px;"
                    >
                    <div style="font-size: 11px; color: #999; margin-top: 4px;">ÊéßÂà∂ËæìÂá∫ÁöÑÈöèÊú∫ÊÄßÔºåË∂äÈ´òË∂äÂàõÊÑè</div>
                </div>

                <div class="parameter-group">
                    <div class="parameter-label">
                        <span>Top P</span>
                        <span class="parameter-value" id="topPValue">0.9</span>
                    </div>
                    <input 
                        type="range" 
                        id="topP" 
                        class="parameter-input" 
                        min="0" 
                        max="1" 
                        step="0.05" 
                        value="0.9"
                        style="padding: 0; height: 6px;"
                    >
                    <div style="font-size: 11px; color: #999; margin-top: 4px;">Ê†∏ÈááÊ†∑ÔºåÂΩ±ÂìçËØçÊ±áÂ§öÊ†∑ÊÄß</div>
                </div>

                <div class="parameter-group">
                    <div class="parameter-label">
                        <span>Top K</span>
                        <span class="parameter-value" id="topKValue">40</span>
                    </div>
                    <input 
                        type="range" 
                        id="topK" 
                        class="parameter-input" 
                        min="0" 
                        max="100" 
                        step="1" 
                        value="40"
                        style="padding: 0; height: 6px;"
                    >
                    <div style="font-size: 11px; color: #999; margin-top: 4px;">Âè™ËÄÉËôëÊúÄÂèØËÉΩÁöÑK‰∏™ËØç</div>
                </div>

                <div class="parameter-group">
                    <div class="parameter-label">
                        <span>Repeat Penalty</span>
                        <span class="parameter-value" id="repeatPenaltyValue">1.1</span>
                    </div>
                    <input 
                        type="range" 
                        id="repeatPenalty" 
                        class="parameter-input" 
                        min="0.5" 
                        max="2" 
                        step="0.05" 
                        value="1.1"
                        style="padding: 0; height: 6px;"
                    >
                    <div style="font-size: 11px; color: #999; margin-top: 4px;">Èò≤Ê≠¢ÈáçÂ§çÔºåË∂äÈ´òÈáçÂ§çË∂äÂ∞ë</div>
                </div>
            </div>

            <div class="data-management">
                <h4>üõ£Ô∏è Ë∑ØÂæÑÁÆ°ÁêÜ</h4>
                <div id="pathSelector" style="margin-bottom: 12px; max-height: 150px; overflow-y: auto;">
                    <!-- Âä®ÊÄÅÊ∏≤ÊüìË∑ØÂæÑÂàóË°® -->
                </div>
            </div>

            <div class="data-management">
                <h4>üíæ Êï∞ÊçÆÂØºÂá∫ÂØºÂÖ•</h4>
                <button class="data-btn" onclick="quickExportData()">üì§ Âø´ÈÄüÂØºÂá∫</button>
                <button class="data-btn" onclick="importData()">üì• ÂØºÂÖ•Êï∞ÊçÆ</button>
                <div style="font-size: 11px; color: #999; margin-top: 8px;">
                    ÂØºÂá∫ÔºöÂØπËØù+ÈìæÊù°+ËÆ∞ÂøÜÂ∫ì
                </div>
            </div>

            <div class="data-management">
                <h4>ÔøΩ ÈìæÊù°ÂØπËØù</h4>
                <button class="data-btn" onclick="showChainDialogueHistory()">üìä Êü•ÁúãÈìæÊù°ËÆ∞ÂΩï</button>
                <button class="data-btn danger" onclick="clearChainExecutions()">üóëÔ∏è Ê∏ÖÁ©∫ËÆ∞ÂΩï</button>
                <div class="save-indicator" id="saveIndicator"></div>
            </div>

            <input type="file" id="fileInput" accept=".json" onchange="handleFileImport(event)">
        </div>
        
        <!-- ‰∏ªËÅäÂ§©Âå∫Âüü -->
        <div class="container">
            <div class="header">
                <h1>AIÂØπËØùÂä©Êâã</h1>
                <p>‰∏éÊú¨Âú∞AIÊ®°ÂûãÂØπËØù</p>
            </div>
            
            <div class="chat-box" id="chatBox"></div>
            
            <div class="input-area">
                <input 
                    type="text" 
                    id="userInput" 
                    placeholder="ËæìÂÖ•‰Ω†ÁöÑÈóÆÈ¢ò..." 
                    autocomplete="off"
                >
                <button id="sendBtn">ÂèëÈÄÅ</button>
            </div>
        </div>
    </div>

    <script>
        'use strict';
        
        // ========== Êï∞ÊçÆÁªìÊûÑ ==========
        class MessageNode {
            constructor(id, text, sender, parentId = null) {
                this.id = id;
                this.text = text;
                this.sender = sender;
                this.parentId = parentId;
                this.childrenIds = [];
            }
        }

        // ========== ÂÖ®Â±ÄÂèòÈáè ==========
        const chatBox = document.getElementById('chatBox');
        const userInput = document.getElementById('userInput');
        const sendBtn = document.getElementById('sendBtn');
        const systemPromptEl = document.getElementById('systemPrompt');
        const modelNameEl = document.getElementById('modelName');
        const branchPanel = document.getElementById('branchPanel');
        const branchTree = document.getElementById('branchTree');
        const contentOverlay = document.getElementById('contentOverlay');
        const saveIndicator = document.getElementById('saveIndicator');
        
        // ÂèÇÊï∞ÂÖÉÁ¥†
        const temperatureEl = document.getElementById('temperature');
        const topPEl = document.getElementById('topP');
        const topKEl = document.getElementById('topK');
        const repeatPenaltyEl = document.getElementById('repeatPenalty');
        const tempValueEl = document.getElementById('tempValue');
        const topPValueEl = document.getElementById('topPValue');
        const topKValueEl = document.getElementById('topKValue');
        const repeatPenaltyValueEl = document.getElementById('repeatPenaltyValue');
        
        // ÈÖçÁΩÆ
        const OLLAMA_API = 'http://localhost:11434/api/generate';
        const STORAGE_KEY = 'ollama_chat_data';
        const VECTOR_DB_KEY = 'ollama_vector_db';
        const VECTOR_DB_INDEX_KEY = 'ollama_vector_db_index';
        const MEMORY_CONFIG_KEY = 'ollama_memory_config';
        let MODEL = 'my-model';

        // Ê∂àÊÅØÊ†ë
        let messageTree = {};
        let nodeIdCounter = 0;
        let currentPathIds = [];
        let isGenerating = false;

        // ÂàÜÊîØÂêëÈáèÂ∫ìÁÆ°ÁêÜÂΩªÂ∫ïÈöîÁ¶ªÔºöÁßªÈô§ÂÖ®Â±ÄÂàÜÊîØÂêëÈáèÂ∫ìÔºåÂÖ®ÈÉ®ÈÄöËøá pathDataMap[pathId].vectorDBMap ÁÆ°ÁêÜ

        // ========== Â§öÈìæÊù°ÂØπËØùÁ≥ªÁªü ==========
        // Phase 1: ÈÖçÁΩÆÂíåÈìæÊù°ÁÆ°ÁêÜ
        let modelConfigs = [];         // Ê®°ÂûãÂàóË°®
        let promptConfigs = [];        // ÊèêÁ§∫ËØçÂàóË°®
        let memoryDBConfigs = [];      // ËÆ∞ÂøÜÂ∫ìÂàóË°®
        let chainConfigs = [];         // ÈìæÊù°ÈÖçÁΩÆÂàóË°®
        let routingRules = [];         // Ë∑ØÁî±ËßÑÂàôÂàóË°®
        let currentChainId = null;     // ÂΩìÂâçÈÄâ‰∏≠ÁöÑÈìæÊù°

        // ========== Phase 2: ÈìæÊù°ÊâßË°åÁ≥ªÁªü ==========
        let executionSession = {
            mode: 'sequential',        // sequential / parallel / branching
            selectedChains: [],        // ÈÄâ‰∏≠ÁöÑÈìæÊù°IDs
            results: {},               // ÊâßË°åÁªìÊûúÔºö{chainId: response}
            isExecuting: false,        // ÊòØÂê¶Ê≠£Âú®ÊâßË°å
            useChainByDefault: true,   // ÈªòËÆ§‰ΩøÁî®ÈìæÊù°
            currentChainPath: [],      // ÂΩìÂâçÈìæÊù°Ë∑ØÂæÑ
            autoSavePath: true,        // ÂàáÊç¢Ë∑ØÂæÑÊó∂Ëá™Âä®‰øùÂ≠òÂΩìÂâçË∑ØÂæÑÊï∞ÊçÆ
            saveMode: 'auto'           // 'auto' Êàñ 'manual'
        };

        // ÈìæÊù°Ë∑ØÂæÑÈÖçÁΩÆ
        let chainPathConfigs = [];     // ‰øùÂ≠òÁöÑÈìæÊù°Ë∑ØÂæÑÈÖçÁΩÆ
        let currentChainPathConfig = null; // ÂΩìÂâçÈÄâ‰∏≠ÁöÑË∑ØÂæÑÈÖçÁΩÆ

        // ========== ÈìæÊù°Ë∑ØÂæÑÊâßË°åËÆ∞ÂΩïÁ≥ªÁªü ==========
        let chainPathExecutions = [];  // ËÆ∞ÂΩïÊâÄÊúâÈìæÊù°Ë∑ØÂæÑÊâßË°åÂéÜÂè≤Ôºö[{id, pathId, nodes: [{chainId, input, output, vectorDB}]}]
        let currentChainPathExecution = null; // ÂΩìÂâçÊ≠£Âú®ÊâßË°åÁöÑÈìæÊù°Ë∑ØÂæÑ execution ËÆ∞ÂΩï
        let chainNodeVectorDBs = {};   // ÈìæÊù°ËäÇÁÇπÁöÑÂêëÈáèÂ∫ìÊò†Â∞ÑÔºö{executionId_nodeIdx: VectorDatabase}

        // ========== Â§öË∑ØÂæÑÁã¨Á´ãÊï∞ÊçÆÁÆ°ÁêÜ ==========
        let pathDataMap = {};           // {pathId: PathDataÂØπË±°}
        let currentActivePath = null;   // ÂΩìÂâçÊ¥ªË∑ÉË∑ØÂæÑID

        // PathData Á±ª - ‰∏∫ÊØè‰∏™Ë∑ØÂæÑÁª¥Êä§Áã¨Á´ãÁöÑÂØπËØùÊï∞ÊçÆ
        class PathData {
            constructor(pathId, pathName) {
                this.pathId = pathId;
                this.pathName = pathName;
                this.messageTree = {};           // ËØ•Ë∑ØÂæÑÁöÑÊ∂àÊÅØÊ†ë
                this.vectorDBMap = {};          // ËØ•Ë∑ØÂæÑÁöÑÂêëÈáèÂ∫ìÊò†Â∞Ñ {branchId: VectorDatabase}
                this.nodeIdCounter = 0;         // ËØ•Ë∑ØÂæÑÁöÑËäÇÁÇπIDËÆ°Êï∞Âô®
                this.currentPathIds = [];       // ËØ•Ë∑ØÂæÑÁöÑÂΩìÂâçÂØπËØùË∑ØÂæÑ
                this.createdAt = Date.now();
                this.lastUpdated = Date.now();
                this.metadata = {
                    messageCount: 0,
                    lastUsed: null,
                    tags: []
                };
                // ‰øÆÂ§çÔºö‰∏∫ÊØè‰∏™Ë∑ØÂæÑÊâßË°åÂàõÂª∫ÈöîÁ¶ªÁöÑÂêëÈáèÂ∫ì
                this.executionVectorDBs = {};   // {executionId_nodeIdx: VectorDatabase} - ÊØè‰∏™ÈìæÊù°ËäÇÁÇπÊâßË°åÁöÑÁã¨Á´ãÂêëÈáèÂ∫ì
            }
        }

        // ========== ÈÖçÁΩÆÁÆ°ÁêÜÂô® ==========
        class ConfigurationManager {
            // Ê®°ÂûãÁÆ°ÁêÜ
            addModel(id, name, type = 'ollama', config = {}) {
                modelConfigs.push({
                    id, name, type, config,
                    createdAt: Date.now()
                });
                saveConfigurations();
                return modelConfigs[modelConfigs.length - 1];
            }

            removeModel(id) {
                modelConfigs = modelConfigs.filter(m => m.id !== id);
                saveConfigurations();
            }

            getModel(id) {
                return modelConfigs.find(m => m.id === id);
            }

            // ÊèêÁ§∫ËØçÁÆ°ÁêÜ
            addPrompt(id, name, content) {
                promptConfigs.push({
                    id, name, content,
                    createdAt: Date.now()
                });
                saveConfigurations();
                return promptConfigs[promptConfigs.length - 1];
            }

            removePrompt(id) {
                promptConfigs = promptConfigs.filter(p => p.id !== id);
                saveConfigurations();
            }

            getPrompt(id) {
                return promptConfigs.find(p => p.id === id);
            }

            // ËÆ∞ÂøÜÂ∫ìÁÆ°ÁêÜ
            addMemoryDB(id, name) {
                memoryDBConfigs.push({
                    id, name,
                    branchVectorDBMapRef: {},  // ÂºïÁî®Âà∞ÂàÜÊîØÂêëÈáèÂ∫ì
                    createdAt: Date.now()
                });
                saveConfigurations();
                return memoryDBConfigs[memoryDBConfigs.length - 1];
            }

            getMemoryDB(id) {
                return memoryDBConfigs.find(m => m.id === id);
            }

            listConfigs() {
                return {
                    models: modelConfigs,
                    prompts: promptConfigs,
                    memoryDBs: memoryDBConfigs
                };
            }
        }

        // ========== ÈìæÊù°ÁÆ°ÁêÜÂô® ==========
        class ChainManager {
            createChain(config) {
                // config: {id, name, modelId, promptId, memoryDBId, parameters: {...}}
                const chain = {
                    ...config,
                    createdAt: Date.now(),
                    connections: [],  // Ëøô‰∏™ÈìæÊù°ËøûÊé•Âà∞Âì™‰∫õÈìæÊù°
                    statistics: {
                        invocations: 0,
                        avgTime: 0,
                        lastUsed: null
                    }
                };
                chainConfigs.push(chain);
                saveChainConfigurations();
                return chain;
            }

            getChain(id) {
                return chainConfigs.find(c => c.id === id);
            }

            updateChain(id, config) {
                const chain = this.getChain(id);
                if (chain) {
                    Object.assign(chain, config);
                    saveChainConfigurations();
                }
                return chain;
            }

            deleteChain(id) {
                chainConfigs = chainConfigs.filter(c => c.id !== id);
                saveChainConfigurations();
            }

            listChains() {
                return chainConfigs;
            }

            connectChains(sourceId, targetId) {
                const source = this.getChain(sourceId);
                if (source && !source.connections.includes(targetId)) {
                    source.connections.push(targetId);
                    saveChainConfigurations();
                }
            }

            disconnectChains(sourceId, targetId) {
                const source = this.getChain(sourceId);
                if (source) {
                    source.connections = source.connections.filter(id => id !== targetId);
                    saveChainConfigurations();
                }
            }
        }

        // ========== Ë∑ØÁî±ÁÆ°ÁêÜÂô® ==========
        class RoutingManager {
            createRoute(config) {
                // config: {id, name, chains: [chainIds], mode: 'sequential'|'parallel'|'branching'}
                const route = {
                    ...config,
                    createdAt: Date.now(),
                    enabled: true
                };
                routingRules.push(route);
                saveRoutingConfigurations();
                return route;
            }

            getRoute(id) {
                return routingRules.find(r => r.id === id);
            }

            deleteRoute(id) {
                routingRules = routingRules.filter(r => r.id !== id);
                saveRoutingConfigurations();
            }

            listRoutes() {
                return routingRules;
            }

            // Ëé∑ÂèñÊé®ËçêÁöÑË∑ØÁî±
            getDefaultRoute() {
                // ËøîÂõûÁ¨¨‰∏ÄÊù°ÂêØÁî®ÁöÑË∑ØÁî±ÔºåÊàñÂàõÂª∫ÈªòËÆ§Ë∑ØÁî±
                const enabled = routingRules.find(r => r.enabled);
                if (!enabled && chainConfigs.length > 0) {
                    return this.createRoute({
                        id: 'default_route',
                        name: 'ÈªòËÆ§Ë∑ØÁî±',
                        chains: [chainConfigs[0].id],
                        mode: 'sequential'
                    });
                }
                return enabled;
            }
        }

        // ========== ÈìæÊù°Ë∑ØÂæÑÁîüÊàêÂô® ==========
        class ChainPathBuilder {
            createPath(config) {
                // config: {id, name, chains: [chainIds], description: '', nodes: [{chainId, permission, executionMode}]}
                // ÊîØÊåÅÁÅµÊ¥ªÁöÑË∑ØÂæÑÔºö[A], [A,B], [A,B,A], [A,B,C,A,B] Á≠â‰ªªÊÑèÁªÑÂêà
                const path = {
                    ...config,
                    id: config.id || `path_${Date.now()}`,
                    createdAt: Date.now(),
                    enabled: true,
                    useCount: 0,
                    lastUsed: null,
                    // Êñ∞Â¢ûÔºöË∑ØÂæÑËäÇÁÇπÈÖçÁΩÆÔºàÊîØÊåÅÊùÉÈôêÂíåÊâßË°åÊ®°ÂºèÔºâ
                    nodes: config.nodes || (config.chains ? config.chains.map((chainId, idx) => ({
                        chainId,
                        permission: 'normal', // normal, advanced, system
                        executionMode: idx < (config.chains.length - 1) ? 'sequential' : 'final' // sequential, parallel, final
                    })) : []),
                    executionModes: config.executionModes || [] // ‰øùÁïôÂêëÂêéÂÖºÂÆπÊÄß
                };
                chainPathConfigs.push(path);
                saveChainPathConfigurations();
                return path;
            }

            getPath(id) {
                return chainPathConfigs.find(p => p.id === id);
            }

            updatePath(id, config) {
                const path = this.getPath(id);
                if (path) {
                    Object.assign(path, config);
                    saveChainPathConfigurations();
                }
                return path;
            }

            deletePath(id) {
                chainPathConfigs = chainPathConfigs.filter(p => p.id !== id);
                saveChainPathConfigurations();
            }

            listPaths() {
                return chainPathConfigs;
            }

            setDefault(id) {
                const path = this.getPath(id);
                if (path) {
                    currentChainPathConfig = path;
                    executionSession.currentChainPath = [...path.chains];
                    saveChainPathConfigurations();
                }
            }

            getDefault() {
                if (currentChainPathConfig && currentChainPathConfig.enabled) {
                    return currentChainPathConfig;
                }
                // Â¶ÇÊûúÊ≤°ÊúâÈªòËÆ§Ë∑ØÂæÑÔºåÂàõÂª∫‰∏Ä‰∏™ÂåÖÂê´ÊâÄÊúâÈìæÊù°ÁöÑÁÆÄÂçïË∑ØÂæÑ
                if (chainConfigs.length > 0) {
                    const defaultPath = this.createPath({
                        id: 'default_path',
                        name: 'ÈªòËÆ§ÈìæÊù°',
                        chains: [chainConfigs[0].id],
                        description: 'ÈªòËÆ§‰ΩøÁî®Á¨¨‰∏ÄÊù°ÈìæÊù°'
                    });
                    this.setDefault(defaultPath.id);
                    return defaultPath;
                }
                return null;
            }

            recordUsage(pathId) {
                const path = this.getPath(pathId);
                if (path) {
                    path.useCount++;
                    path.lastUsed = Date.now();
                    saveChainPathConfigurations();
                }
            }
        }

        // ========== Phase 2: ÈìæÊù°ÊâßË°åÂºïÊìé ==========
        class DialogueExecutor {
            async executeChain(chainId, userMessage, previousContext = '') {
                const chain = chainManager.getChain(chainId);
                if (!chain) throw new Error(`ÈìæÊù° ${chainId} ‰∏çÂ≠òÂú®`);

                const model = configManager.getModel(chain.modelId);
                const prompt = configManager.getPrompt(chain.promptId);
                if (!model || !prompt) throw new Error('ÈìæÊù°ÈÖçÁΩÆ‰∏çÂÆåÊï¥');

                // ÊûÑÂª∫ÂÆåÊï¥ÁöÑÊèêÁ§∫ËØç
                let fullPrompt = prompt.content + '\n\n';
                if (previousContext) {
                    fullPrompt += 'ÂâçÁΩÆ‰ø°ÊÅØ:\n' + previousContext + '\n\n';
                }
                fullPrompt += 'Áî®Êà∑: ' + userMessage;

                try {
                    const response = await fetch(OLLAMA_API, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            model: MODEL,
                            prompt: fullPrompt,
                            stream: false,
                            temperature: parseFloat(temperatureEl.value),
                            top_p: parseFloat(topPEl.value),
                            top_k: parseInt(topKEl.value),
                            repeat_penalty: parseFloat(repeatPenaltyEl.value)
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`APIÈîôËØØ: ${response.status}`);
                    }

                    const data = await response.json();
                    return {
                        chainId: chainId,
                        chainName: chain.name,
                        response: data.response,
                        timestamp: Date.now(),
                        success: true
                    };
                } catch (error) {
                    return {
                        chainId: chainId,
                        chainName: chain.name,
                        error: error.message,
                        timestamp: Date.now(),
                        success: false
                    };
                }
            }

            async executeSequential(chainIds, userMessage) {
                const results = [];
                let context = userMessage;

                for (const chainId of chainIds) {
                    const result = await this.executeChain(chainId, context);
                    results.push(result);

                    if (!result.success) {
                        results.push({
                            error: 'ÈìæÊù°ÊâßË°åÂ§±Ë¥•ÔºåÂÅúÊ≠¢ÂêéÁª≠ÊâßË°å',
                            success: false
                        });
                        break;
                    }

                    // ‰∏ã‰∏Ä‰∏™ÈìæÊù°ÁöÑËæìÂÖ•ÊòØÂΩìÂâçÈìæÊù°ÁöÑËæìÂá∫
                    context = result.response;
                }

                return results;
            }

            async executeParallel(chainIds, userMessage) {
                const promises = chainIds.map(chainId =>
                    this.executeChain(chainId, userMessage)
                );

                const results = await Promise.all(promises);
                return results;
            }

            async executeBranching(mainChainId, branchChainIds, userMessage) {
                // ÂÖàÊâßË°å‰∏ªÈìæÊù°
                const mainResult = await this.executeChain(mainChainId, userMessage);
                const results = [mainResult];

                if (mainResult.success) {
                    // ‰ª•‰∏ªÈìæÊù°ÁöÑËæìÂá∫‰Ωú‰∏∫ÂàÜÊîØÈìæÊù°ÁöÑËæìÂÖ•
                    const branchPromises = branchChainIds.map(chainId =>
                        this.executeChain(chainId, mainResult.response)
                    );

                    const branchResults = await Promise.all(branchPromises);
                    results.push(...branchResults);
                }

                return results;
            }

            async execute(mode, chainIds, userMessage) {
                if (mode === 'sequential') {
                    return await this.executeSequential(chainIds, userMessage);
                } else if (mode === 'parallel') {
                    return await this.executeParallel(chainIds, userMessage);
                } else if (mode === 'branching' && chainIds.length > 1) {
                    return await this.executeBranching(chainIds[0], chainIds.slice(1), userMessage);
                } else {
                    throw new Error('Êú™Áü•ÁöÑÊâßË°åÊ®°Âºè');
                }
            }
        }

        // ÂÆû‰æãÂåñÁÆ°ÁêÜÂô®ÂíåÊâßË°åÂô®
        const configManager = new ConfigurationManager();
        const chainManager = new ChainManager();
        const routingManager = new RoutingManager();
        const chainPathBuilder = new ChainPathBuilder();
        const dialogueExecutor = new DialogueExecutor();

        // ========== ÈÖçÁΩÆÊåÅ‰πÖÂåñ ==========
        function saveConfigurations() {
            try {
                const configData = {
                    models: modelConfigs,
                    prompts: promptConfigs,
                    memoryDBs: memoryDBConfigs
                };
                localStorage.setItem('ollama_configurations', JSON.stringify(configData));
            } catch (error) {
                console.error('ÈÖçÁΩÆ‰øùÂ≠òÂ§±Ë¥•:', error);
            }
        }

        function loadConfigurations() {
            try {
                const data = JSON.parse(localStorage.getItem('ollama_configurations'));
                if (data) {
                    modelConfigs = data.models || [];
                    promptConfigs = data.prompts || [];
                    memoryDBConfigs = data.memoryDBs || [];
                }
            } catch (error) {
                console.error('ÈÖçÁΩÆÂä†ËΩΩÂ§±Ë¥•:', error);
            }
        }

        function saveChainConfigurations() {
            try {
                localStorage.setItem('ollama_chains', JSON.stringify(chainConfigs));
            } catch (error) {
                console.error('ÈìæÊù°ÈÖçÁΩÆ‰øùÂ≠òÂ§±Ë¥•:', error);
            }
        }

        function loadChainConfigurations() {
            try {
                const data = JSON.parse(localStorage.getItem('ollama_chains'));
                if (data) {
                    chainConfigs = data;
                }
            } catch (error) {
                console.error('ÈìæÊù°ÈÖçÁΩÆÂä†ËΩΩÂ§±Ë¥•:', error);
            }
        }

        function saveRoutingConfigurations() {
            try {
                localStorage.setItem('ollama_routing_rules', JSON.stringify(routingRules));
            } catch (error) {
                console.error('Ë∑ØÁî±ËßÑÂàô‰øùÂ≠òÂ§±Ë¥•:', error);
            }
        }

        function loadRoutingConfigurations() {
            try {
                const data = JSON.parse(localStorage.getItem('ollama_routing_rules'));
                if (data) {
                    routingRules = data;
                }
            } catch (error) {
                console.error('Ë∑ØÁî±ËßÑÂàôÂä†ËΩΩÂ§±Ë¥•:', error);
            }
        }

        function saveChainPathConfigurations() {
            try {
                const pathData = {
                    paths: chainPathConfigs,
                    currentPathId: currentChainPathConfig?.id || null,
                    useChainByDefault: executionSession.useChainByDefault
                };
                localStorage.setItem('ollama_chain_paths', JSON.stringify(pathData));
            } catch (error) {
                console.error('ÈìæÊù°Ë∑ØÂæÑÈÖçÁΩÆ‰øùÂ≠òÂ§±Ë¥•:', error);
            }
        }

        function loadChainPathConfigurations() {
            try {
                const data = JSON.parse(localStorage.getItem('ollama_chain_paths'));
                if (data) {
                    chainPathConfigs = data.paths || [];
                    if (data.currentPathId) {
                        currentChainPathConfig = chainPathConfigs.find(p => p.id === data.currentPathId);
                    }
                    if (data.useChainByDefault !== undefined) {
                        executionSession.useChainByDefault = data.useChainByDefault;
                    }
                }
            } catch (error) {
                console.error('ÈìæÊù°Ë∑ØÂæÑÈÖçÁΩÆÂä†ËΩΩÂ§±Ë¥•:', error);
            }
        }

        // ========== ÈìæÊù°Ë∑ØÂæÑÊâßË°åËÆ∞ÂΩïÊåÅ‰πÖÂåñ ==========
        function saveChainPathExecutions() {
            try {
                // ‰∏ç‰øùÂ≠òÂÆåÊï¥ÁöÑ VectorDatabase ÂØπË±°ÔºåÂè™‰øùÂ≠òÂÖÉÊï∞ÊçÆ
                const executionsData = chainPathExecutions.map(exec => ({
                    id: exec.id,
                    pathId: exec.pathId,
                    pathName: exec.pathName,
                    startTime: exec.startTime,
                    endTime: exec.endTime,
                    status: exec.status,
                    nodes: exec.nodes.map(node => ({
                        idx: node.idx,
                        chainId: node.chainId,
                        chainName: node.chainName,
                        input: node.input,
                        previousOutput: node.previousOutput,
                        output: node.output,
                        status: node.status,
                        error: node.error,
                        model: node.model,
                        executionTime: node.executionTime
                    }))
                }));
                localStorage.setItem('ollama_chain_path_executions', JSON.stringify(executionsData));
            } catch (error) {
                console.error('ÈìæÊù°Ë∑ØÂæÑÊâßË°åËÆ∞ÂΩï‰øùÂ≠òÂ§±Ë¥•:', error);
            }
        }

        function loadChainPathExecutions() {
            try {
                const data = JSON.parse(localStorage.getItem('ollama_chain_path_executions'));
                if (data && Array.isArray(data)) {
                    chainPathExecutions = data;
                }
            } catch (error) {
                console.error('ÈìæÊù°Ë∑ØÂæÑÊâßË°åËÆ∞ÂΩïÂä†ËΩΩÂ§±Ë¥•:', error);
            }
        }

        // ========== ÂêëÈáèÊï∞ÊçÆÂ∫ìÁ≥ªÁªü ==========
        class VectorDatabase {
            constructor() {
                this.vectors = {}; // Â≠òÂÇ®ÂêëÈáèÊï∞ÊçÆÔºö{messageId: {vector: [], text: '', timestamp: date}}
                this.vocabulary = new Map(); // ËØçÊ±áË°®
                this.docFreq = new Map(); // ÊñáÊ°£È¢ëÁéá
                this.totalDocs = 0;
            }

            // ÂàÜËØçÂáΩÊï∞
            tokenize(text) {
                return text.toLowerCase()
                    .replace(/[^\w\s\u4e00-\u9fa5]/g, ' ')
                    .split(/\s+/)
                    .filter(token => token.length > 0);
            }

            // ÊûÑÂª∫ËØçÊ±áË°®
            buildVocabulary(tokens) {
                tokens.forEach(token => {
                    if (!this.vocabulary.has(token)) {
                        this.vocabulary.set(token, this.vocabulary.size);
                    }
                });
            }

            // ËÆ°ÁÆóTF-IDFÂêëÈáè
            computeTFIDF(tokens) {
                const tf = new Map();
                tokens.forEach(token => {
                    tf.set(token, (tf.get(token) || 0) + 1);
                });

                // ÂΩí‰∏ÄÂåñTF
                let vector = new Array(this.vocabulary.size).fill(0);
                let normFactor = 0;

                tf.forEach((count, token) => {
                    if (this.vocabulary.has(token)) {
                        const idx = this.vocabulary.get(token);
                        const idf = Math.log((this.totalDocs + 1) / ((this.docFreq.get(token) || 0) + 1));
                        vector[idx] = (count / tokens.length) * idf;
                        normFactor += vector[idx] * vector[idx];
                    }
                });

                // L2ÂΩí‰∏ÄÂåñ
                if (normFactor > 0) {
                    normFactor = Math.sqrt(normFactor);
                    vector = vector.map(v => v / normFactor);
                }

                return vector;
            }

            // Ê∑ªÂä†ÊñáÊ°£Âà∞ÂêëÈáèÂ∫ì
            addDocument(messageId, text, timestamp = Date.now()) {
                const tokens = this.tokenize(text);
                this.buildVocabulary(tokens);

                // Êõ¥Êñ∞ÊñáÊ°£È¢ëÁéá
                const uniqueTokens = new Set(tokens);
                uniqueTokens.forEach(token => {
                    this.docFreq.set(token, (this.docFreq.get(token) || 0) + 1);
                });

                this.totalDocs++;

                // ÈáçÊñ∞ËÆ°ÁÆóÊâÄÊúâÂêëÈáèÔºàÂõ†‰∏∫ËØçÊ±áË°®ÊîπÂèò‰∫ÜÔºâ
                this.recomputeAllVectors();

                // ‰øùÂ≠òÊñ∞ÊñáÊ°£
                this.vectors[messageId] = {
                    vector: this.computeTFIDF(tokens),
                    text: text,
                    tokens: tokens,
                    timestamp: timestamp
                };
            }

            // ÈáçÊñ∞ËÆ°ÁÆóÊâÄÊúâÂêëÈáè
            recomputeAllVectors() {
                Object.keys(this.vectors).forEach(msgId => {
                    const data = this.vectors[msgId];
                    data.vector = this.computeTFIDF(data.tokens);
                });
            }

            // ‰ΩôÂº¶Áõ∏‰ººÂ∫¶
            cosineSimilarity(vec1, vec2) {
                if (vec1.length !== vec2.length) return 0;

                let dotProduct = 0;
                let norm1 = 0;
                let norm2 = 0;

                for (let i = 0; i < vec1.length; i++) {
                    dotProduct += vec1[i] * vec2[i];
                    norm1 += vec1[i] * vec1[i];
                    norm2 += vec2[i] * vec2[i];
                }

                const denom = Math.sqrt(norm1) * Math.sqrt(norm2);
                return denom > 0 ? dotProduct / denom : 0;
            }

            // ÊêúÁ¥¢Áõ∏‰ººÁöÑÊ∂àÊÅØ
            search(queryText, topK = 5) {
                const queryTokens = this.tokenize(queryText);
                const queryVector = this.computeTFIDF(queryTokens);

                const results = [];
                Object.entries(this.vectors).forEach(([msgId, data]) => {
                    const similarity = this.cosineSimilarity(queryVector, data.vector);
                    if (similarity > 0.1) { // ËÆæÁΩÆÁõ∏‰ººÂ∫¶ÈòàÂÄº
                        results.push({
                            messageId: msgId,
                            text: data.text,
                            similarity: similarity,
                            timestamp: data.timestamp
                        });
                    }
                });

                results.sort((a, b) => b.similarity - a.similarity);
                return results.slice(0, topK);
            }

            // ÂØºÂá∫ÂêëÈáèÂ∫ì
            export() {
                return {
                    vectors: this.vectors,
                    vocabulary: Array.from(this.vocabulary.entries()),
                    docFreq: Array.from(this.docFreq.entries()),
                    totalDocs: this.totalDocs
                };
            }

            // ÂØºÂÖ•ÂêëÈáèÂ∫ì
            import(data) {
                this.vectors = data.vectors || {};
                this.vocabulary = new Map(data.vocabulary || []);
                this.docFreq = new Map(data.docFreq || []);
                this.totalDocs = data.totalDocs || 0;
            }
        }

        // ========== ÂàÜÊîØÂêëÈáèÂ∫ìÁÆ°ÁêÜÂáΩÊï∞ ==========
        function getCurrentBranchId() {
            // Âü∫‰∫éÂΩìÂâçË∑ØÂæÑÁîüÊàêÂàÜÊîØID
            if (currentPathIds.length === 0) return 'default';
            let rootId = currentPathIds[0];
            let node = messageTree[rootId];
            while (node && node.parentId !== null) {
                rootId = node.parentId;
                node = messageTree[rootId];
            }
            return `branch_${rootId}`;
        }

        function getCurrentVectorDB() {
            // ÈÄöËøáÂΩìÂâçË∑ØÂæÑIDÂíåÂàÜÊîØIDËé∑ÂèñÂàÜÊîØÂêëÈáèÂ∫ì
            const pathData = pathDataMap[currentActivePath];
            if (!pathData) return null;
            const branchId = getCurrentBranchId();
            if (!pathData.vectorDBMap[branchId]) {
                pathData.vectorDBMap[branchId] = new VectorDatabase();
            }
            return pathData.vectorDBMap[branchId];
        }

        // ========== ÂàùÂßãÂåñ ==========
        function init() {
            modelNameEl.textContent = MODEL;
            loadData();
            loadConfigurations();
            loadChainConfigurations();
            loadChainPathConfigurations();
            loadChainPathExecutions();
            loadPathDataFromStorage();  // Âä†ËΩΩÂ§öË∑ØÂæÑÊï∞ÊçÆ
            loadRoutingConfigurations();
            attachEventListeners();
            initializeDefaultChains();  // ÂàùÂßãÂåñÈªòËÆ§ÈìæÊù°

            // ÂàùÂßãÂåñÂΩìÂâçÊ¥ªË∑ÉË∑ØÂæÑ
            if (!currentActivePath && chainPathConfigs.length > 0) {
                const defaultPath = chainPathBuilder.getDefault();
                currentActivePath = defaultPath?.id || chainPathConfigs[0].id;
                if (currentActivePath && !pathDataMap[currentActivePath]) {
                    initializePathData(currentActivePath);
                }
            }

            // Ê∏≤ÊüìË∑ØÂæÑÈÄâÊã©Âô®
            renderPathSelector();
        }

        // ÂàùÂßãÂåñÈªòËÆ§ÈìæÊù°
        function initializeDefaultChains() {
            // Â¶ÇÊûúÊ≤°Êúâ‰ªª‰ΩïÈìæÊù°ÔºåÂàõÂª∫ÈªòËÆ§ÁöÑ
            if (chainConfigs.length === 0) {
                // Ê∑ªÂä†ÈªòËÆ§Ê®°ÂûãÔºàÂ∏¶ÁîüÊàêÂèÇÊï∞Ôºâ
                if (modelConfigs.length === 0) {
                    configManager.addModel('ollama-default', 'ÈªòËÆ§Ê®°Âûã', 'ollama', {
                        temperature: 0.7,
                        top_p: 0.9,
                        top_k: 40,
                        repeat_penalty: 1.1
                    });
                }

                // Ê∑ªÂä†ÈªòËÆ§ÊèêÁ§∫ËØç
                if (promptConfigs.length === 0) {
                    configManager.addPrompt('default', 'ÈªòËÆ§Âä©Êâã', '‰Ω†ÊòØ‰∏Ä‰∏™ÊúâÁî®ÁöÑAIÂä©Êâã„ÄÇËØ∑Áî®‰∏≠ÊñáÂõûÁ≠îÈóÆÈ¢òÔºåÊèê‰æõÂáÜÁ°Æ„ÄÅÊúâÂ∏ÆÂä©ÁöÑ‰ø°ÊÅØ„ÄÇ');
                }

                // Ê∑ªÂä†ÈªòËÆ§ËÆ∞ÂøÜÂ∫ìÔºàÈìæÊù°ÂØπËØù‰ΩøÁî®Ôºâ
                if (memoryDBConfigs.length === 0) {
                    configManager.addMemoryDB('memory-chain', 'ÈìæÊù°ÂØπËØùËÆ∞ÂøÜÂ∫ì');
                }

                // ÂàõÂª∫ÈªòËÆ§ÈìæÊù°
                chainManager.createChain({
                    id: 'chain_default',
                    name: 'ÈªòËÆ§ÈìæÊù°',
                    modelId: 'ollama-default',
                    promptId: 'default',
                    memoryDBId: 'memory-chain',
                    parameters: {
                        temperature: 0.7,
                        top_p: 0.9,
                        top_k: 40,
                        repeat_penalty: 1.1
                    }
                });

                // ÂàõÂª∫ÈªòËÆ§ÈìæÊù°Ë∑ØÂæÑ
                chainPathBuilder.createPath({
                    id: 'path_default',
                    name: 'ÈªòËÆ§ÈìæÊù°Ë∑ØÂæÑ',
                    chains: ['chain_default'],
                    description: '‰ΩøÁî®ÈªòËÆ§ÈìæÊù°ÁöÑÂØπËØùË∑ØÂæÑ'
                });

                chainPathBuilder.setDefault('path_default');
            }
        }
        
        function attachEventListeners() {
            // ÂèÇÊï∞ÊªëÂùó‰∫ã‰ª∂
            temperatureEl.addEventListener('input', e => {
                tempValueEl.textContent = parseFloat(e.target.value).toFixed(1);
            });
            topPEl.addEventListener('input', e => {
                topPValueEl.textContent = parseFloat(e.target.value).toFixed(2);
            });
            topKEl.addEventListener('input', e => {
                topKValueEl.textContent = e.target.value;
            });
            repeatPenaltyEl.addEventListener('input', e => {
                repeatPenaltyValueEl.textContent = parseFloat(e.target.value).toFixed(2);
            });
            
            // Ê∂àÊÅØÂèëÈÄÅ
            sendBtn.addEventListener('click', sendMessage);
            userInput.addEventListener('keypress', e => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    sendMessage();
                }
            });
        }

        // ========== Â§öË∑ØÂæÑÁÆ°ÁêÜÂáΩÊï∞ ==========
        // ÂàùÂßãÂåñÊàñËé∑ÂèñË∑ØÂæÑÊï∞ÊçÆ
        function initializePathData(pathId) {
            if (!pathDataMap[pathId]) {
                const pathName = chainPathBuilder.getPath(pathId)?.name || 'Êú™Áü•Ë∑ØÂæÑ';
                pathDataMap[pathId] = new PathData(pathId, pathName);
            }
            return pathDataMap[pathId];
        }

        // ÂàáÊç¢Âà∞ÊåáÂÆöË∑ØÂæÑ
        function switchToPath(pathId) {
            if (!chainPathBuilder.getPath(pathId)) {
                alert('Ë∑ØÂæÑ‰∏çÂ≠òÂú®');
                return;
            }

            // ‰øùÂ≠òÂΩìÂâçË∑ØÂæÑÊï∞ÊçÆÔºàÊ†πÊçÆÁî®Êà∑ËÆæÁΩÆÔºâ
            if (currentActivePath && executionSession.autoSavePath) {
                savePathData(currentActivePath);
            }

            // ÂàáÊç¢Âà∞Êñ∞Ë∑ØÂæÑ
            currentActivePath = pathId;
            const pathData = initializePathData(pathId);

            // ÊÅ¢Â§çË∑ØÂæÑÊï∞ÊçÆ
            restorePathData(pathData);

            // Êõ¥Êñ∞UI
            renderCurrentBranch();
            updateVectorDBInfo();
            renderPathSelector();
            showSaveIndicator(`‚úì Â∑≤ÂàáÊç¢Âà∞Ë∑ØÂæÑ: ${pathData.pathName}`);
        }

        // ‰øùÂ≠òÂΩìÂâçË∑ØÂæÑÁöÑÊï∞ÊçÆ
        function savePathData(pathId) {
            if (!pathDataMap[pathId]) return;

            const pathData = pathDataMap[pathId];
            pathData.messageTree = messageTree;
            pathData.nodeIdCounter = nodeIdCounter;
            pathData.currentPathIds = currentPathIds;
            // ÂàÜÊîØÂêëÈáèÂ∫ìÂ∑≤ÂΩªÂ∫ïÈöîÁ¶ªÔºåÊó†ÈúÄËµãÂÄºÂÖ®Â±ÄÂèòÈáè
            pathData.lastUpdated = Date.now();
            pathData.metadata.messageCount = Object.keys(messageTree).length;

            // ‰øùÂ≠òÂà∞ localStorage
            savePathDataToStorage();
        }

        // ÊÅ¢Â§çÊåáÂÆöË∑ØÂæÑÁöÑÊï∞ÊçÆ
        function restorePathData(pathData) {
            messageTree = pathData.messageTree;
            nodeIdCounter = pathData.nodeIdCounter;
            currentPathIds = pathData.currentPathIds;
            // ÂàÜÊîØÂêëÈáèÂ∫ìÂ∑≤ÂΩªÂ∫ïÈöîÁ¶ªÔºåÊó†ÈúÄËµãÂÄºÂÖ®Â±ÄÂèòÈáè
        }

        // ‰øùÂ≠òÊâÄÊúâË∑ØÂæÑÊï∞ÊçÆÂà∞ localStorage
        function savePathDataToStorage() {
            try {
                const pathsToSave = {};
                Object.entries(pathDataMap).forEach(([pathId, pathData]) => {
                    pathsToSave[pathId] = {
                        pathName: pathData.pathName,
                        messageTree: pathData.messageTree,
                        nodeIdCounter: pathData.nodeIdCounter,
                        currentPathIds: pathData.currentPathIds,
                        lastUpdated: pathData.lastUpdated,
                        metadata: pathData.metadata
                    };
                });
                localStorage.setItem('ollama_path_data_map', JSON.stringify(pathsToSave));

                // ‰øùÂ≠òÂêÑË∑ØÂæÑÁöÑÂêëÈáèÂ∫ì
                const vectorDBsData = {};
                Object.entries(pathDataMap).forEach(([pathId, pathData]) => {
                    vectorDBsData[pathId] = {};
                    Object.entries(pathData.vectorDBMap).forEach(([branchId, vdb]) => {
                        vectorDBsData[pathId][branchId] = vdb.export();
                    });
                });
                localStorage.setItem('ollama_path_vector_dbs', JSON.stringify(vectorDBsData));

            } catch (error) {
                console.error('‰øùÂ≠òË∑ØÂæÑÊï∞ÊçÆÂ§±Ë¥•:', error);
            }
        }

        // ‰ªé localStorage ÊÅ¢Â§çË∑ØÂæÑÊï∞ÊçÆ
        function loadPathDataFromStorage() {
            try {
                const pathsData = JSON.parse(localStorage.getItem('ollama_path_data_map'));
                const vectorDBsData = JSON.parse(localStorage.getItem('ollama_path_vector_dbs'));

                if (pathsData) {
                    Object.entries(pathsData).forEach(([pathId, data]) => {
                        const pathData = new PathData(pathId, data.pathName);
                        pathData.messageTree = data.messageTree || {};
                        pathData.nodeIdCounter = data.nodeIdCounter || 0;
                        pathData.currentPathIds = data.currentPathIds || [];
                        pathData.lastUpdated = data.lastUpdated || Date.now();
                        pathData.metadata = data.metadata || {};

                        // ÊÅ¢Â§çÂêëÈáèÂ∫ì
                        if (vectorDBsData && vectorDBsData[pathId]) {
                            Object.entries(vectorDBsData[pathId]).forEach(([branchId, vdbData]) => {
                                const vdb = new VectorDatabase();
                                vdb.import(vdbData);
                                pathData.vectorDBMap[branchId] = vdb;
                            });
                        }

                        pathDataMap[pathId] = pathData;
                    });
                }
            } catch (error) {
                console.error('Âä†ËΩΩË∑ØÂæÑÊï∞ÊçÆÂ§±Ë¥•:', error);
            }
        }

        // ========== Êï∞ÊçÆÊåÅ‰πÖÂåñ ==========
        function saveData() {
            try {
                const data = {
                    messageTree,
                    nodeIdCounter,
                    currentPathIds
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
                saveAllVectorDBs();
                showSaveIndicator('‚úì Â∑≤‰øùÂ≠ò');
            } catch (error) {
                console.error('‰øùÂ≠òÂ§±Ë¥•:', error);
                showSaveIndicator('‚úó ‰øùÂ≠òÂ§±Ë¥•');
            }
        }

        function loadData() {
            try {
                const data = JSON.parse(localStorage.getItem(STORAGE_KEY));
                if (data) {
                    messageTree = data.messageTree || {};
                    nodeIdCounter = data.nodeIdCounter || 0;
                    currentPathIds = data.currentPathIds || [];

                    // ÊÅ¢Â§çMessageNodeÂØπË±°
                    Object.keys(messageTree).forEach(key => {
                        const node = messageTree[key];
                        if (typeof node === 'object' && !node.constructor.name.includes('MessageNode')) {
                            messageTree[key] = Object.assign(new MessageNode(0, '', 'user'), node);
                        }
                    });

                    loadAllVectorDBs();
                    renderCurrentBranch();
                    showSaveIndicator('‚úì Â∑≤Âä†ËΩΩ');
                }
            } catch (error) {
                console.error('Âä†ËΩΩÂ§±Ë¥•:', error);
            }
        }

        // ========== ÂàÜÊîØÂêëÈáèÂ∫ìÊåÅ‰πÖÂåñ ==========
        // ‰øùÂ≠òÂΩìÂâçË∑ØÂæÑ‰∏ãÊâÄÊúâÂàÜÊîØÂêëÈáèÂ∫ìÂà∞Êú¨Âú∞
        function saveCurrentPathVectorDBs() {
            try {
                const pathData = pathDataMap[currentActivePath];
                if (!pathData) return;
                const vectorDBIndex = {};
                Object.entries(pathData.vectorDBMap).forEach(([branchId, vdb]) => {
                    vectorDBIndex[branchId] = vdb.export();
                });
                localStorage.setItem(VECTOR_DB_INDEX_KEY + '_' + currentActivePath, JSON.stringify(vectorDBIndex));
            } catch (error) {
                console.error('ÂΩìÂâçË∑ØÂæÑÂàÜÊîØÂêëÈáèÂ∫ì‰øùÂ≠òÂ§±Ë¥•:', error);
            }
        }

        // Âä†ËΩΩÂΩìÂâçË∑ØÂæÑ‰∏ãÊâÄÊúâÂàÜÊîØÂêëÈáèÂ∫ì
        function loadCurrentPathVectorDBs() {
            try {
                const pathData = pathDataMap[currentActivePath];
                if (!pathData) return;
                const vectorDBIndex = JSON.parse(localStorage.getItem(VECTOR_DB_INDEX_KEY + '_' + currentActivePath));
                if (vectorDBIndex) {
                    Object.entries(vectorDBIndex).forEach(([branchId, data]) => {
                        const vectorDB = new VectorDatabase();
                        vectorDB.import(data);
                        pathData.vectorDBMap[branchId] = vectorDB;
                    });
                }
            } catch (error) {
                console.error('ÂΩìÂâçË∑ØÂæÑÂàÜÊîØÂêëÈáèÂ∫ìÂä†ËΩΩÂ§±Ë¥•:', error);
            }
        }

        function saveCurrentVectorDB() {
            const vectorDB = getCurrentVectorDB();
            const branchId = getCurrentBranchId();
            try {
                const vectorDBIndex = JSON.parse(localStorage.getItem(VECTOR_DB_INDEX_KEY)) || {};
                vectorDBIndex[branchId] = vectorDB.export();
                localStorage.setItem(VECTOR_DB_INDEX_KEY, JSON.stringify(vectorDBIndex));
            } catch (error) {
                console.error('ÂΩìÂâçÂàÜÊîØÂêëÈáèÂ∫ì‰øùÂ≠òÂ§±Ë¥•:', error);
            }
        }

        // ========== Ëé∑ÂèñÈïøÊúüËÆ∞ÂøÜ‰∏ä‰∏ãÊñá ==========
        function getMemoryContext(userMessage, topK = 3) {
            const vectorDB = getCurrentVectorDB();
            const searchResults = vectorDB.search(userMessage, topK);
            if (searchResults.length === 0) return '';

            let contextStr = '\n„ÄêÁõ∏ÂÖ≥ÂéÜÂè≤ÂØπËØù„Äë\n';
            searchResults.forEach((result, idx) => {
                const date = new Date(result.timestamp).toLocaleString('zh-CN');
                contextStr += `${idx + 1}. [${date}] Áõ∏‰ººÂ∫¶${(result.similarity * 100).toFixed(1)}%: ${result.text.substring(0, 100)}\n`;
            });

            return contextStr;
        }
        
        function showSaveIndicator(text) {
            saveIndicator.textContent = text;
            saveIndicator.classList.add('success');
            setTimeout(() => {
                saveIndicator.textContent = '';
                saveIndicator.classList.remove('success');
            }, 1500);
        }

        function clearChainExecutions() {
            if (!confirm('Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâÈìæÊù°ÊâßË°åËÆ∞ÂΩïÂêóÔºü')) return;
            chainPathExecutions = [];
            chainNodeVectorDBs = {};
            saveChainPathExecutions();
            showSaveIndicator('‚úì ËÆ∞ÂΩïÂ∑≤Ê∏ÖÁ©∫');
        }

        // ========== ËÆ∞ÂøÜÂ∫ì‰ºòÂåñÂáΩÊï∞ ==========
        function showOptimizeMemoryDialog(memoryId) {
            const memory = configManager.getMemoryDB(memoryId);
            if (!memory) return;

            // ËÆ°ÁÆóËØ•ËÆ∞ÂøÜÂ∫ìË¢´‰ΩøÁî®ÁöÑÈìæÊù°
            const chainsUsingMemory = chainConfigs.filter(c => c.memoryDBId === memoryId);

            // ÂàõÂª∫‰ºòÂåñÂØπËØùÊ°Ü
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center;
                z-index: 5000;
            `;

            const content = document.createElement('div');
            content.style.cssText = `
                background: white; border-radius: 12px; padding: 24px; max-width: 500px;
                box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            `;

            const title = document.createElement('h2');
            title.textContent = `üßπ ‰ºòÂåñËÆ∞ÂøÜÂ∫ì: ${memory.name}`;
            title.style.cssText = 'margin: 0 0 16px 0; color: #333;';

            const info = document.createElement('div');
            info.style.cssText = `
                background: #f0f7ff; padding: 12px; border-radius: 6px;
                margin-bottom: 16px; border-left: 3px solid #d373cb;
            `;

            // ÁªüËÆ°ÂΩìÂâçË∑ØÂæÑ‰∏ãÊâÄÊúâÂàÜÊîØÂêëÈáèÂ∫ì
            let totalVectors = 0;
            const pathData = pathDataMap[currentActivePath];
            if (pathData) {
                Object.values(pathData.vectorDBMap).forEach(vdb => {
                    totalVectors += Object.keys(vdb.vectors || {}).length;
                });
            }

            info.innerHTML = `
                <div style="font-size: 13px; color: #333; line-height: 1.8;">
                    <div>üìä ËÆ∞ÂøÜÂ∫ìÁªüËÆ°Ôºö</div>
                    <div>‚Ä¢ ÊÄªÂêëÈáèÊï∞: <strong>${totalVectors}</strong></div>
                    <div>‚Ä¢ Ë¢´ <strong>${chainsUsingMemory.length}</strong> ‰∏™ÈìæÊù°‰ΩøÁî®</div>
                    <div style="margin-top: 12px; color: #d373cb; font-weight: 600;">
                        ÈÄâÊã©Âà†Èô§ÁôæÂàÜÊØîÔºåÁ≥ªÁªüÂ∞ÜÂà†Èô§ÊúÄÊó©Âá∫Áé∞ÁöÑÂØπËØùËΩÆÊ¨°
                    </div>
                </div>
            `;

            const sliderContainer = document.createElement('div');
            sliderContainer.style.cssText = 'margin: 20px 0;';

            const label = document.createElement('label');
            label.style.cssText = 'display: flex; justify-content: space-between; margin-bottom: 8px;';
            label.innerHTML = `
                <span style="font-weight: 600; color: #333;">Âà†Èô§ÊØî‰æã</span>
                <span style="color: #d373cb; font-weight: 600;" id="percentageDisplay">10%</span>
            `;

            const slider = document.createElement('input');
            slider.type = 'range';
            slider.min = '0';
            slider.max = '100';
            slider.value = '10';
            slider.style.cssText = 'width: 100%; height: 6px; cursor: pointer;';

            slider.addEventListener('input', (e) => {
                document.getElementById('percentageDisplay').textContent = e.target.value + '%';
            });

            sliderContainer.appendChild(label);
            sliderContainer.appendChild(slider);

            const warning = document.createElement('div');
            warning.style.cssText = `
                background: #fff3cd; padding: 12px; border-radius: 6px;
                border-left: 3px solid #ffc107; color: #856404; font-size: 12px;
                margin-bottom: 16px; line-height: 1.6;
            `;
            warning.innerHTML = `
                ‚ö†Ô∏è <strong>Ë≠¶Âëä:</strong> Âà†Èô§ÁöÑÊï∞ÊçÆÊó†Ê≥ïÊÅ¢Â§ç„ÄÇÁ≥ªÁªüÂ∞Ü‰ºòÂÖàÂà†Èô§ÊúÄÊó©Âá∫Áé∞ÁöÑÂØπËØùËÆ∞ÂøÜ„ÄÇ
                Âª∫ËÆÆÂú®‰ºòÂåñÂâçÂØºÂá∫Â§á‰ªΩ„ÄÇ
            `;

            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = 'display: flex; gap: 8px;';

            const confirmBtn = document.createElement('button');
            confirmBtn.textContent = 'Á°ÆËÆ§‰ºòÂåñ';
            confirmBtn.style.cssText = `
                flex: 1; padding: 10px; background: #d373cb; color: white;
                border: none; border-radius: 6px; cursor: pointer; font-weight: 600;
            `;
            confirmBtn.onclick = () => {
                const percentage = parseInt(slider.value);
                optimizeVectorDBByPercentage(memoryId, percentage);
                modal.remove();
            };

            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'ÂèñÊ∂à';
            cancelBtn.style.cssText = `
                flex: 1; padding: 10px; background: #999; color: white;
                border: none; border-radius: 6px; cursor: pointer; font-weight: 600;
            `;
            cancelBtn.onclick = () => modal.remove();

            buttonContainer.appendChild(confirmBtn);
            buttonContainer.appendChild(cancelBtn);

            content.appendChild(title);
            content.appendChild(info);
            content.appendChild(sliderContainer);
            content.appendChild(warning);
            content.appendChild(buttonContainer);
            modal.appendChild(content);
            document.body.appendChild(modal);
        }

        // ÊåâÁôæÂàÜÊØî‰ºòÂåñÂêëÈáèÂ∫ìÔºàÂà†Èô§ÊúÄÊó©Âá∫Áé∞ÁöÑÂØπËØùËΩÆÊ¨°Ôºâ
        function optimizeVectorDBByPercentage(memoryId, percentage) {
            try {
                const chainsUsingMemory = chainConfigs.filter(c => c.memoryDBId === memoryId);
                if (chainsUsingMemory.length === 0) {
                    showSaveIndicator('‚ÑπÔ∏è Ê≠§ËÆ∞ÂøÜÂ∫ìÊú™Ë¢´‰ªª‰ΩïÈìæÊù°‰ΩøÁî®');
                    return;
                }
                // Âè™Ê∏ÖÁêÜÂΩìÂâçË∑ØÂæÑ‰∏ãÁöÑÂàÜÊîØÂêëÈáèÂ∫ì
                const pathData = pathDataMap[currentActivePath];
                if (!pathData) return;
                let allVectors = [];
                Object.entries(pathData.vectorDBMap).forEach(([branchId, vdb]) => {
                    Object.entries(vdb.vectors || {}).forEach(([msgId, data]) => {
                        allVectors.push({
                            msgId,
                            msgId_num: parseInt(msgId),
                            branchId,
                            vectorDB: vdb
                        });
                    });
                });
                allVectors.sort((a, b) => a.msgId_num - b.msgId_num);
                const deleteCount = Math.floor(allVectors.length * (percentage / 100));
                for (let i = 0; i < deleteCount; i++) {
                    const { msgId, vectorDB } = allVectors[i];
                    delete vectorDB.vectors[msgId];
                    if (vectorDB.recomputeAllVectors) {
                        vectorDB.recomputeAllVectors();
                    }
                }
                // ‰øùÂ≠òÂΩìÂâçË∑ØÂæÑÁöÑÂêëÈáèÂ∫ì
                saveCurrentPathVectorDBs();
                showSaveIndicator(`‚úì ‰ºòÂåñÂÆåÊàêÔºåÂà†Èô§ ${deleteCount} Êù°ÊúÄÊó©ÁöÑËÆ∞ÂΩï`);
            } catch (error) {
                console.error('‰ºòÂåñÂ§±Ë¥•:', error);
                showSaveIndicator('‚úó ‰ºòÂåñÂ§±Ë¥•');
            }
        }

        // ========== ÂØºÂÖ•ÂØºÂá∫ ==========
        // Âø´ÈÄüÂØºÂá∫ÔºöÂØπËØùËÆ∞ÂΩï + ÈìæÊù°ËÆ∞ÂΩï + ËÆ∞ÂøÜÂ∫ìÈÖçÁΩÆ
        function quickExportData() {
            try {
                // Ëé∑ÂèñÂΩìÂâçË∑ØÂæÑÁöÑÂØπËØùÊï∞ÊçÆ
                const pathData = pathDataMap[currentActivePath];
                if (!pathData) {
                    alert('ÂΩìÂâçË∑ØÂæÑÊó†ÊïàÔºåÊó†Ê≥ïÂØºÂá∫');
                    return;
                }

                // Êî∂ÈõÜÂΩìÂâçË∑ØÂæÑÁöÑÂêëÈáèÂ∫ì
                const currentVectorDBs = {};
                Object.entries(pathData.vectorDBMap).forEach(([branchId, vectorDB]) => {
                    currentVectorDBs[branchId] = vectorDB.export();
                });

                // Êî∂ÈõÜÊâÄÊúâËÆ∞ÂøÜÂ∫ìÈÖçÁΩÆÂíåÁªüËÆ°‰ø°ÊÅØ
                const memoriesData = memoryDBConfigs.map(memory => {
                    const chainsUsingMemory = chainConfigs.filter(c => c.memoryDBId === memory.id);
                    return {
                        id: memory.id,
                        name: memory.name,
                        usageCount: chainsUsingMemory.length,
                        chainsUsing: chainsUsingMemory.map(c => ({ id: c.id, name: c.name }))
                    };
                });

                // ÁªÑÂêàÂØºÂá∫Êï∞ÊçÆ
                const data = {
                    exportType: 'quick-export',
                    version: '2.0',
                    timestamp: Date.now(),
                    exportDate: new Date().toLocaleString(),

                    // ÂΩìÂâçÂØπËØùËÆ∞ÂΩï
                    chat: {
                        pathId: currentActivePath,
                        pathName: pathData.pathName,
                        messageTree: pathData.messageTree,
                        nodeIdCounter: pathData.nodeIdCounter,
                        currentPathIds: pathData.currentPathIds,
                        messageCount: Object.keys(pathData.messageTree).length,
                        vectorDBs: currentVectorDBs
                    },

                    // ÈìæÊù°ÊâßË°åËÆ∞ÂΩï
                    chainExecutions: {
                        totalCount: chainPathExecutions.length,
                        executions: chainPathExecutions
                    },

                    // ËÆ∞ÂøÜÂ∫ì‰ø°ÊÅØ
                    memories: {
                        totalCount: memoryDBConfigs.length,
                        configs: memoriesData
                    },

                    // ÈìæÊù°ÈÖçÁΩÆ
                    chains: {
                        totalCount: chainConfigs.length,
                        configs: chainConfigs.map(c => ({
                            id: c.id,
                            name: c.name,
                            models: c.models,
                            memoryDBId: c.memoryDBId
                        }))
                    }
                };

                // ÁîüÊàêÊñá‰ª∂
                const jsonString = JSON.stringify(data, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ollama-export-${currentActivePath}-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showSaveIndicator(`‚úì ÂØºÂá∫ÊàêÂäü (ÂØπËØù+ÈìæÊù°+${memoryDBConfigs.length}‰∏™ËÆ∞ÂøÜÂ∫ì)`);
            } catch (error) {
                console.error('Âø´ÈÄüÂØºÂá∫Â§±Ë¥•:', error);
                showSaveIndicator('‚úó ÂØºÂá∫Â§±Ë¥•');
            }
        }

        function exportData() {
            // ÂàõÂª∫ÂØºÂá∫ÈÄâÈ°πÂØπËØùÊ°Ü
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center;
                z-index: 5000;
            `;

            const content = document.createElement('div');
            content.style.cssText = `
                background: white; border-radius: 12px; padding: 24px; max-width: 600px;
                box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            `;

            const title = document.createElement('h2');
            title.textContent = 'üì§ ÂØºÂá∫Êï∞ÊçÆ';
            title.style.cssText = 'margin: 0 0 20px 0; color: #333;';

            // ÈÄâÈ°π1ÔºöÂØºÂá∫‰∏ªÂØπËØùËÆ∞ÂΩï
            const option1 = document.createElement('label');
            option1.style.cssText = 'display: flex; align-items: center; gap: 12px; margin-bottom: 12px; cursor: pointer;';
            option1.innerHTML = `
                <input type="radio" name="exportType" value="chat" checked style="cursor: pointer;">
                <div>
                    <div style="font-weight: 600; color: #333;">üí¨ ‰∏ªÂØπËØùËÆ∞ÂΩï</div>
                    <div style="font-size: 12px; color: #666;">ÂΩìÂâçË∑ØÂæÑÁöÑÊâÄÊúâËÅäÂ§©ÂÜÖÂÆπ„ÄÅÂàÜÊîØÂíåÂêëÈáèÂ∫ì</div>
                </div>
            `;

            // ÈÄâÈ°π2ÔºöÂØºÂá∫ÈìæÊù°ÊâßË°åËÆ∞ÂΩï
            const option2 = document.createElement('label');
            option2.style.cssText = 'display: flex; align-items: center; gap: 12px; margin-bottom: 12px; cursor: pointer;';
            option2.innerHTML = `
                <input type="radio" name="exportType" value="chain" style="cursor: pointer;">
                <div>
                    <div style="font-weight: 600; color: #333;">üîó ÈìæÊù°ÊâßË°åËÆ∞ÂΩï</div>
                    <div style="font-size: 12px; color: #666;">ÊâÄÊúâÈìæÊù°ÊâßË°åÂéÜÂè≤ÂíåÁªìÊûú</div>
                </div>
            `;

            // ÈÄâÈ°π3ÔºöÂØºÂá∫ÈÄâÂÆöË∑ØÂæÑ
            const option3 = document.createElement('label');
            option3.style.cssText = 'display: flex; align-items: center; gap: 12px; margin-bottom: 12px; cursor: pointer;';
            option3.innerHTML = `
                <input type="radio" name="exportType" value="paths" style="cursor: pointer;">
                <div>
                    <div style="font-weight: 600; color: #333;">üéÅ ÈÄâÂÆöË∑ØÂæÑ</div>
                    <div style="font-size: 12px; color: #666;">ÈÄâÊã©Ë¶ÅÂØºÂá∫ÁöÑÂ§ö‰∏™Ë∑ØÂæÑ</div>
                </div>
            `;

            // ÈÄâÈ°π4ÔºöÂØºÂá∫ÂÖ®ÈÉ®
            const option4 = document.createElement('label');
            option4.style.cssText = 'display: flex; align-items: center; gap: 12px; margin-bottom: 20px; cursor: pointer;';
            option4.innerHTML = `
                <input type="radio" name="exportType" value="all" style="cursor: pointer;">
                <div>
                    <div style="font-weight: 600; color: #333;">üéÅ ÂÆåÊï¥Â§á‰ªΩ</div>
                    <div style="font-size: 12px; color: #666;">ÊâÄÊúâÂØπËØù„ÄÅÈìæÊù°ÈÖçÁΩÆ„ÄÅÊâßË°åËÆ∞ÂΩï</div>
                </div>
            `;

            const buttons = document.createElement('div');
            buttons.style.cssText = 'display: flex; gap: 8px;';

            const exportBtn = document.createElement('button');
            exportBtn.textContent = 'ÂØºÂá∫';
            exportBtn.style.cssText = `
                flex: 1; padding: 10px; background: #d373cb; color: white;
                border: none; border-radius: 6px; cursor: pointer; font-weight: 600;
            `;
            exportBtn.onclick = () => {
                const type = document.querySelector('input[name="exportType"]:checked').value;
                performExport(type);
                modal.remove();
            };

            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'ÂèñÊ∂à';
            cancelBtn.style.cssText = `
                flex: 1; padding: 10px; background: #999; color: white;
                border: none; border-radius: 6px; cursor: pointer; font-weight: 600;
            `;
            cancelBtn.onclick = () => modal.remove();

            buttons.appendChild(exportBtn);
            buttons.appendChild(cancelBtn);

            content.appendChild(title);
            content.appendChild(option1);
            content.appendChild(option2);
            content.appendChild(option3);
            content.appendChild(option4);
            content.appendChild(buttons);
            modal.appendChild(content);
            document.body.appendChild(modal);
        }

        function performExport(type) {
            try {
                let data = {};
                let filename = '';

                if (type === 'chat') {
                    // ÂØºÂá∫ÂΩìÂâçË∑ØÂæÑÁöÑÂØπËØùËÆ∞ÂΩï
                    const pathData = pathDataMap[currentActivePath];
                    if (!pathData) {
                        alert('ÂΩìÂâçË∑ØÂæÑÊó†Êïà');
                        return;
                    }

                    const allVectorDBs = {};
                    Object.entries(pathData.vectorDBMap).forEach(([branchId, vectorDB]) => {
                        allVectorDBs[branchId] = vectorDB.export();
                    });

                    data = {
                        exportType: 'chat',
                        pathId: currentActivePath,
                        pathName: pathData.pathName,
                        messageTree: pathData.messageTree,
                        nodeIdCounter: pathData.nodeIdCounter,
                        currentPathIds: pathData.currentPathIds,
                        branchVectorDBs: allVectorDBs
                    };
                    filename = `ollama-chat-${currentActivePath}-${Date.now()}.json`;
                } else if (type === 'chain') {
                    // ÂØºÂá∫ÈìæÊù°ÊâßË°åËÆ∞ÂΩï
                    data = {
                        exportType: 'chain',
                        chainPathExecutions: chainPathExecutions,
                        timestamp: Date.now()
                    };
                    filename = `ollama-chain-execution-${Date.now()}.json`;
                } else if (type === 'paths') {
                    // ÂØºÂá∫ÈÄâÂÆöÁöÑÂ§ö‰∏™Ë∑ØÂæÑ
                    showPathSelectionDialog((selectedPathIds) => {
                        if (selectedPathIds.length === 0) {
                            alert('ËØ∑Ëá≥Â∞ëÈÄâÊã©‰∏Ä‰∏™Ë∑ØÂæÑ');
                            return;
                        }
                        performSelectedPathsExport(selectedPathIds);
                    });
                    return;
                } else if (type === 'all') {
                    // ÂØºÂá∫ÂÖ®ÈÉ®
                    const allPaths = {};
                    const allVectorDBs = {};

                    Object.entries(pathDataMap).forEach(([pathId, pathData]) => {
                        allPaths[pathId] = {
                            pathName: pathData.pathName,
                            messageTree: pathData.messageTree,
                            nodeIdCounter: pathData.nodeIdCounter,
                            currentPathIds: pathData.currentPathIds,
                            lastUpdated: pathData.lastUpdated,
                            metadata: pathData.metadata
                        };

                        allVectorDBs[pathId] = {};
                        Object.entries(pathData.vectorDBMap).forEach(([branchId, vdb]) => {
                            allVectorDBs[pathId][branchId] = vdb.export();
                        });
                    });

                    data = {
                        exportType: 'all',
                        version: '2.0',
                        timestamp: Date.now(),
                        paths: allPaths,
                        vectorDBsData: allVectorDBs,
                        currentActivePath: currentActivePath,
                        chainPathExecutions: chainPathExecutions,
                        configurations: {
                            modelConfigs,
                            promptConfigs,
                            memoryDBConfigs,
                            chainConfigs,
                            chainPathConfigs,
                            routingRules
                        },
                        customPrompt: systemPromptEl.value
                    };
                    filename = `ollama-backup-all-${Date.now()}.json`;
                }

                if (data && Object.keys(data).length > 0) {
                    const jsonString = JSON.stringify(data, null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    showSaveIndicator('‚úì ÂØºÂá∫ÊàêÂäü');
                }
            } catch (error) {
                console.error('ÂØºÂá∫Â§±Ë¥•:', error);
                showSaveIndicator('‚úó ÂØºÂá∫Â§±Ë¥•');
            }
        }

        // ÈÄâÂÆöË∑ØÂæÑÂØºÂá∫
        function performSelectedPathsExport(selectedPathIds) {
            try {
                const pathsToExport = {};
                const vectorDBsToExport = {};

                selectedPathIds.forEach(pathId => {
                    const pathData = pathDataMap[pathId];
                    if (pathData) {
                        pathsToExport[pathId] = {
                            pathName: pathData.pathName,
                            messageTree: pathData.messageTree,
                            nodeIdCounter: pathData.nodeIdCounter,
                            currentPathIds: pathData.currentPathIds,
                            lastUpdated: pathData.lastUpdated,
                            metadata: pathData.metadata
                        };

                        vectorDBsToExport[pathId] = {};
                        Object.entries(pathData.vectorDBMap).forEach(([branchId, vdb]) => {
                            vectorDBsToExport[pathId][branchId] = vdb.export();
                        });
                    }
                });

                const data = {
                    exportType: 'paths',
                    paths: pathsToExport,
                    vectorDBsData: vectorDBsToExport,
                    timestamp: Date.now()
                };

                const jsonString = JSON.stringify(data, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ollama-paths-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showSaveIndicator(`‚úì ÂØºÂá∫ ${selectedPathIds.length} Êù°Ë∑ØÂæÑÊàêÂäü`);
            } catch (error) {
                console.error('ÂØºÂá∫Â§±Ë¥•:', error);
                showSaveIndicator('‚úó ÂØºÂá∫Â§±Ë¥•');
            }
        }

        // ÊòæÁ§∫Ë∑ØÂæÑÈÄâÊã©ÂØπËØùÊ°Ü
        function showPathSelectionDialog(callback) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center;
                z-index: 5000;
            `;

            const content = document.createElement('div');
            content.style.cssText = `
                background: white; border-radius: 12px; padding: 24px; max-width: 500px; max-height: 600px;
                box-shadow: 0 20px 60px rgba(0,0,0,0.3); overflow-y: auto;
            `;

            const title = document.createElement('h2');
            title.textContent = 'üì§ ÈÄâÊã©Ë¶ÅÂØºÂá∫ÁöÑË∑ØÂæÑ';
            title.style.cssText = 'margin: 0 0 20px 0; color: #333;';

            let pathCheckboxes = {};

            const pathList = document.createElement('div');
            pathList.style.cssText = 'margin-bottom: 20px;';

            Object.entries(pathDataMap).forEach(([pathId, pathData]) => {
                const label = document.createElement('label');
                label.style.cssText = 'display: flex; align-items: center; gap: 12px; margin-bottom: 10px; cursor: pointer;';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = false;
                checkbox.style.cssText = 'cursor: pointer; width: 18px; height: 18px;';

                const info = document.createElement('div');
                info.style.cssText = 'flex: 1;';
                info.innerHTML = `
                    <div style="font-weight: 600; color: #333; font-size: 13px;">${pathData.pathName}</div>
                    <div style="font-size: 11px; color: #999;">Ê∂àÊÅØÊï∞: ${pathData.metadata.messageCount || 0}</div>
                `;

                label.appendChild(checkbox);
                label.appendChild(info);
                pathList.appendChild(label);

                pathCheckboxes[pathId] = checkbox;
            });

            const buttons = document.createElement('div');
            buttons.style.cssText = 'display: flex; gap: 8px;';

            const selectAllBtn = document.createElement('button');
            selectAllBtn.textContent = 'ÂÖ®ÈÄâ';
            selectAllBtn.style.cssText = `
                flex: 1; padding: 10px; background: #f0f0f0; color: #333;
                border: 1px solid #ddd; border-radius: 6px; cursor: pointer; font-weight: 600;
            `;
            selectAllBtn.onclick = () => {
                Object.values(pathCheckboxes).forEach(cb => cb.checked = true);
            };

            const exportBtn = document.createElement('button');
            exportBtn.textContent = 'ÂØºÂá∫';
            exportBtn.style.cssText = `
                flex: 1; padding: 10px; background: #d373cb; color: white;
                border: none; border-radius: 6px; cursor: pointer; font-weight: 600;
            `;
            exportBtn.onclick = () => {
                const selectedPathIds = Object.keys(pathCheckboxes).filter(pathId => pathCheckboxes[pathId].checked);
                callback(selectedPathIds);
                modal.remove();
            };

            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'ÂèñÊ∂à';
            cancelBtn.style.cssText = `
                flex: 1; padding: 10px; background: #999; color: white;
                border: none; border-radius: 6px; cursor: pointer; font-weight: 600;
            `;
            cancelBtn.onclick = () => modal.remove();

            buttons.appendChild(selectAllBtn);
            buttons.appendChild(exportBtn);
            buttons.appendChild(cancelBtn);

            content.appendChild(title);
            content.appendChild(pathList);
            content.appendChild(buttons);
            modal.appendChild(content);
            document.body.appendChild(modal);
        }

        function importData() {
            document.getElementById('fileInput').click();
        }

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);

                    if (data.exportType === 'quick-export') {
                        // ÂØºÂÖ•Âø´ÈÄüÂØºÂá∫ÁöÑÊñá‰ª∂ÔºàÂØπËØù+ÈìæÊù°+ËÆ∞ÂøÜÂ∫ìÔºâ
                        if (confirm('ÂØºÂÖ•Âø´ÈÄüÂ§á‰ªΩÊñá‰ª∂ÔºüÊ≠§Êìç‰Ωú‰ºöÂØºÂÖ•ÂØπËØù„ÄÅÈìæÊù°ËÆ∞ÂΩïÂíåËÆ∞ÂøÜÂ∫ì‰ø°ÊÅØ„ÄÇ')) {
                            // ÂØºÂÖ•ÂØπËØùËÆ∞ÂΩï
                            if (data.chat) {
                                const pathId = data.chat.pathId;
                                const pathData = initializePathData(pathId);
                                pathData.messageTree = data.chat.messageTree || {};
                                pathData.nodeIdCounter = data.chat.nodeIdCounter || 0;
                                pathData.currentPathIds = data.chat.currentPathIds || [];
                                pathData.vectorDBMap = {};

                                // ÊÅ¢Â§çÂØπËØùÁöÑÂêëÈáèÂ∫ì
                                if (data.chat.vectorDBs) {
                                    Object.entries(data.chat.vectorDBs).forEach(([branchId, vectorDBData]) => {
                                        const vectorDB = new VectorDatabase();
                                        vectorDB.import(vectorDBData);
                                        pathData.vectorDBMap[branchId] = vectorDB;
                                    });
                                }

                                // ÂàáÊç¢Âà∞ÂØºÂÖ•ÁöÑË∑ØÂæÑ
                                switchToPath(pathId);
                            }

                            // ÂØºÂÖ•ÈìæÊù°ÊâßË°åËÆ∞ÂΩï
                            if (data.chainExecutions && data.chainExecutions.executions) {
                                const shouldMerge = confirm('ÊòØÂê¶Â∞ÜÈìæÊù°ËÆ∞ÂΩï‰∏éÁé∞ÊúâËÆ∞ÂΩïÂêàÂπ∂ÔºüÔºàÂèñÊ∂àÂàôÊõøÊç¢Ôºâ');
                                if (shouldMerge) {
                                    chainPathExecutions = chainPathExecutions.concat(data.chainExecutions.executions);
                                } else {
                                    chainPathExecutions = data.chainExecutions.executions || [];
                                }
                            }

                            // ‰øùÂ≠òÊâÄÊúâÊï∞ÊçÆ
                            savePathDataToStorage();
                            saveChainPathExecutions();
                            renderPathSelector();

                            showSaveIndicator(`‚úì ÂØºÂÖ•ÊàêÂäü (ÂØπËØù+ÈìæÊù°ËÆ∞ÂΩï)`);
                        }

                    } else if (data.exportType === 'chat') {
                        // ÂØºÂÖ•ÂØπËØùËÆ∞ÂΩïÂà∞ÊåáÂÆöË∑ØÂæÑ
                        const pathId = data.pathId || `import_${Date.now()}`;
                        const pathData = initializePathData(pathId);

                        // ÊÅ¢Â§çÂØπËØùÊï∞ÊçÆ
                        pathData.messageTree = data.messageTree || {};
                        pathData.nodeIdCounter = data.nodeIdCounter || 0;
                        pathData.currentPathIds = data.currentPathIds || [];
                        pathData.vectorDBMap = {};

                        if (data.branchVectorDBs) {
                            Object.entries(data.branchVectorDBs).forEach(([branchId, vectorDBData]) => {
                                const vectorDB = new VectorDatabase();
                                vectorDB.import(vectorDBData);
                                pathData.vectorDBMap[branchId] = vectorDB;
                            });
                        }

                        // ÂàáÊç¢Âà∞ÂØºÂÖ•ÁöÑË∑ØÂæÑ
                        switchToPath(pathId);
                        savePathDataToStorage();
                        renderPathSelector();
                        showSaveIndicator('‚úì ÂØπËØùËÆ∞ÂΩïÂØºÂÖ•ÊàêÂäü');

                    } else if (data.exportType === 'chain') {
                        // ÂØºÂÖ•ÈìæÊù°ÊâßË°åËÆ∞ÂΩï
                        if (confirm('ÊòØÂê¶Â∞ÜÂØºÂÖ•ÁöÑÈìæÊù°ÊâßË°åËÆ∞ÂΩïÂêàÂπ∂Âà∞Áé∞ÊúâËÆ∞ÂΩïÔºü')) {
                            chainPathExecutions = chainPathExecutions.concat(data.chainPathExecutions || []);
                        } else {
                            chainPathExecutions = data.chainPathExecutions || [];
                        }
                        saveChainPathExecutions();
                        showSaveIndicator('‚úì ÈìæÊù°ÊâßË°åËÆ∞ÂΩïÂØºÂÖ•ÊàêÂäü');

                    } else if (data.exportType === 'all') {
                        // ÂØºÂÖ•ÂÆåÊï¥Â§á‰ªΩÔºåÊîØÊåÅÈÄâÊã©ÊÄßÂêàÂπ∂
                        if (Object.keys(pathDataMap).length > 0 && !confirm('Â∑≤Â≠òÂú®Êú¨Âú∞Êï∞ÊçÆ„ÄÇÊòØÂê¶ÂÆåÂÖ®Ë¶ÜÁõñÔºàÂèñÊ∂àÂàôÂêàÂπ∂Êñ∞Êï∞ÊçÆÔºâÔºü')) {
                            // ÂêàÂπ∂Ê®°ÂºèÔºöÂØºÂÖ•Êñ∞Ë∑ØÂæÑ
                            if (data.paths) {
                                Object.entries(data.paths).forEach(([pathId, pathInfo]) => {
                                    if (!pathDataMap[pathId]) {
                                        const newPathData = new PathData(pathId, pathInfo.pathName);
                                        newPathData.messageTree = pathInfo.messageTree || {};
                                        newPathData.nodeIdCounter = pathInfo.nodeIdCounter || 0;
                                        newPathData.currentPathIds = pathInfo.currentPathIds || [];
                                        newPathData.lastUpdated = pathInfo.lastUpdated || Date.now();
                                        newPathData.metadata = pathInfo.metadata || {};

                                        // ÊÅ¢Â§çÂêëÈáèÂ∫ì
                                        if (data.vectorDBsData && data.vectorDBsData[pathId]) {
                                            Object.entries(data.vectorDBsData[pathId]).forEach(([branchId, vdbData]) => {
                                                const vdb = new VectorDatabase();
                                                vdb.import(vdbData);
                                                newPathData.vectorDBMap[branchId] = vdb;
                                            });
                                        }

                                        pathDataMap[pathId] = newPathData;
                                    }
                                });
                            }
                            showSaveIndicator('‚úì ÂØºÂÖ•ÊàêÂäüÔºàÂêàÂπ∂Ê®°ÂºèÔºâ');
                        } else {
                            // Ë¶ÜÁõñÊ®°ÂºèÔºöÂÆåÂÖ®ÊõøÊç¢ÊâÄÊúâÊï∞ÊçÆ
                            pathDataMap = {};

                            if (data.paths) {
                                Object.entries(data.paths).forEach(([pathId, pathInfo]) => {
                                    const pathData = new PathData(pathId, pathInfo.pathName);
                                    pathData.messageTree = pathInfo.messageTree || {};
                                    pathData.nodeIdCounter = pathInfo.nodeIdCounter || 0;
                                    pathData.currentPathIds = pathInfo.currentPathIds || [];
                                    pathData.lastUpdated = pathInfo.lastUpdated || Date.now();
                                    pathData.metadata = pathInfo.metadata || {};

                                    // ÊÅ¢Â§çÂêëÈáèÂ∫ì
                                    if (data.vectorDBsData && data.vectorDBsData[pathId]) {
                                        Object.entries(data.vectorDBsData[pathId]).forEach(([branchId, vdbData]) => {
                                            const vdb = new VectorDatabase();
                                            vdb.import(vdbData);
                                            pathData.vectorDBMap[branchId] = vdb;
                                        });
                                    }

                                    pathDataMap[pathId] = pathData;
                                });
                            }

                            // ÊÅ¢Â§çÂΩìÂâçË∑ØÂæÑ
                            currentActivePath = data.currentActivePath;

                            // ÊÅ¢Â§çÈìæÊù°ÊâßË°åËÆ∞ÂΩï
                            chainPathExecutions = data.chainPathExecutions || [];

                            // ÊÅ¢Â§çÈÖçÁΩÆ
                            if (data.configurations) {
                                modelConfigs = data.configurations.modelConfigs || [];
                                promptConfigs = data.configurations.promptConfigs || [];
                                memoryDBConfigs = data.configurations.memoryDBConfigs || [];
                                chainConfigs = data.configurations.chainConfigs || [];
                                chainPathConfigs = data.configurations.chainPathConfigs || [];
                                routingRules = data.configurations.routingRules || [];
                                saveConfigurations();
                                saveChainConfigurations();
                                saveChainPathConfigurations();
                                saveRoutingConfigurations();
                            }

                            if (data.customPrompt) {
                                systemPromptEl.value = data.customPrompt;
                            }

                            showSaveIndicator('‚úì ÂÆåÊï¥Â§á‰ªΩÂØºÂÖ•ÊàêÂäüÔºàË¶ÜÁõñÊ®°ÂºèÔºâ');
                        }

                        // ‰øùÂ≠òÊï∞ÊçÆÂπ∂Âà∑Êñ∞UI
                        savePathDataToStorage();
                        saveChainPathExecutions();
                        renderPathSelector();
                        renderCurrentBranch();

                    } else if (data.exportType === 'paths') {
                        // ÂØºÂÖ•ÈÄâÂÆöÁöÑÂ§ö‰∏™Ë∑ØÂæÑ
                        const pathsToImport = data.paths || {};
                        const pathIds = Object.keys(pathsToImport);

                        if (pathIds.length === 0) {
                            alert('Êñá‰ª∂‰∏≠Ê≤°ÊúâË∑ØÂæÑÊï∞ÊçÆ');
                            return;
                        }

                        let mergeMode = true;
                        if (Object.keys(pathDataMap).length > 0) {
                            mergeMode = !confirm('ÊòØÂê¶ÂÆåÂÖ®Ë¶ÜÁõñÁé∞ÊúâÊï∞ÊçÆÔºüÔºàÂèñÊ∂àÂàôÂêàÂπ∂Ôºâ');
                        }

                        if (!mergeMode) {
                            pathDataMap = {};
                        }

                        Object.entries(pathsToImport).forEach(([pathId, pathInfo]) => {
                            const pathData = new PathData(pathId, pathInfo.pathName);
                            pathData.messageTree = pathInfo.messageTree || {};
                            pathData.nodeIdCounter = pathInfo.nodeIdCounter || 0;
                            pathData.currentPathIds = pathInfo.currentPathIds || [];
                            pathData.lastUpdated = pathInfo.lastUpdated || Date.now();
                            pathData.metadata = pathInfo.metadata || {};

                            if (data.vectorDBsData && data.vectorDBsData[pathId]) {
                                Object.entries(data.vectorDBsData[pathId]).forEach(([branchId, vdbData]) => {
                                    const vdb = new VectorDatabase();
                                    vdb.import(vdbData);
                                    pathData.vectorDBMap[branchId] = vdb;
                                });
                            }

                            pathDataMap[pathId] = pathData;
                        });

                        savePathDataToStorage();
                        renderPathSelector();
                        showSaveIndicator(`‚úì ÂØºÂÖ• ${pathIds.length} Êù°Ë∑ØÂæÑÊàêÂäü`);

                    } else {
                        // ÂÖºÂÆπÊóßÊ†ºÂºè
                        const pathId = 'legacy_import';
                        const pathData = initializePathData(pathId);

                        pathData.messageTree = data.messageTree || {};
                        pathData.nodeIdCounter = data.nodeIdCounter || 0;
                        pathData.currentPathIds = data.currentPathIds || [];
                        pathData.vectorDBMap = {};

                        if (data.branchVectorDBs) {
                            Object.entries(data.branchVectorDBs).forEach(([branchId, vectorDBData]) => {
                                const vectorDB = new VectorDatabase();
                                vectorDB.import(vectorDBData);
                                pathData.vectorDBMap[branchId] = vectorDB;
                            });
                        }

                        switchToPath(pathId);
                        savePathDataToStorage();
                        renderPathSelector();
                        showSaveIndicator('‚úì ÊóßÊ†ºÂºèÊï∞ÊçÆÂØºÂÖ•ÊàêÂäü');
                    }
                } catch (error) {
                    console.error('ÂØºÂÖ•Â§±Ë¥•:', error);
                    showSaveIndicator('‚úó ÂØºÂÖ•Â§±Ë¥•');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function clearAllData() {
            if (!confirm('Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâÂØπËØùÂíåÂàÜÊîØÂêóÔºüÊ≠§Êìç‰ΩúÊó†Ê≥ïÊí§ÈîÄÔºÅ')) return;

            messageTree = {};
            nodeIdCounter = 0;
            currentPathIds = [];
            // ÂàÜÊîØÂêëÈáèÂ∫ìÂ∑≤ÂΩªÂ∫ïÈöîÁ¶ªÔºåÊó†ÈúÄËµãÂÄºÂÖ®Â±ÄÂèòÈáè
            chatBox.innerHTML = '';
            localStorage.removeItem(STORAGE_KEY);
            localStorage.removeItem(VECTOR_DB_INDEX_KEY);
            updateVectorDBInfo();
            showSaveIndicator('‚úì Â∑≤Ê∏ÖÁ©∫');
        }

        // ========== Ë∑ØÂæÑÈÄâÊã©Âô®UI ==========
        function renderPathSelector() {
            const container = document.getElementById('pathSelector');
            if (!container) return;

            let html = '';
            chainPathConfigs.forEach(path => {
                const isActive = currentActivePath === path.id;
                html += `
                    <div style="padding: 8px; background: ${isActive ? '#e8f0ff' : '#f9f9f9'};
                                border: 1px solid ${isActive ? '#d373cb' : '#ddd'};
                                border-radius: 4px; margin-bottom: 6px; cursor: pointer;
                                ${isActive ? 'border-left: 3px solid #d373cb;' : ''}"
                         onclick="switchToPath('${path.id}')">
                        <div style="font-weight: ${isActive ? '600' : '400'}; color: ${isActive ? '#d373cb' : '#333'}; font-size: 12px;">
                            ${isActive ? '‚úì ' : ''}${path.name}
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        
        // ========== ÂàÜÊîØÈù¢ÊùøÁÆ°ÁêÜ ==========
        function toggleBranchPanel() {
            branchPanel.classList.toggle('active');
            contentOverlay.classList.toggle('active');
            updateBranchTree();
        }
        
        function closeBranchPanel() {
            branchPanel.classList.remove('active');
            contentOverlay.classList.remove('active');
        }
        
        function updateBranchTree() {
            branchTree.innerHTML = '';
            
            const rootNodes = Object.values(messageTree).filter(n => n.parentId === null);
            
            if (rootNodes.length === 0) {
                branchTree.innerHTML = '<p style="padding: 20px; color: #999; text-align: center;">ËøòÊ≤°ÊúâÂØπËØù</p>';
                return;
            }
            
            rootNodes.forEach(node => {
                branchTree.appendChild(renderBranchNode(node));
            });
        }
        
        function renderBranchNode(node) {
            const nodeEl = document.createElement('div');
            nodeEl.className = 'branch-node';
            nodeEl.dataset.nodeId = node.id;
            
            const isInCurrentPath = currentPathIds.includes(node.id);
            const hasChildren = node.childrenIds.length > 0;
            
            if (isInCurrentPath && node.id === currentPathIds[currentPathIds.length - 1]) {
                nodeEl.classList.add('active');
            }
            
            const nodeHeader = document.createElement('div');
            nodeHeader.className = 'branch-node-header';
            
            // Â±ïÂºÄ/Êî∂Èó≠ÊåâÈíÆ
            let childrenDiv = null;
            if (hasChildren) {
                const toggleIcon = document.createElement('span');
                toggleIcon.className = 'branch-toggle-icon';
                toggleIcon.textContent = '‚ñæ';
                toggleIcon.style.cursor = 'pointer';
                
                childrenDiv = document.createElement('div');
                childrenDiv.className = 'branch-node-children expanded';
                
                node.childrenIds.forEach(childId => {
                    const childNode = messageTree[childId];
                    if (childNode) {
                        childrenDiv.appendChild(renderBranchNode(childNode));
                    }
                });
                
                toggleIcon.addEventListener('click', (e) => {
                    e.stopPropagation();
                    childrenDiv.classList.toggle('expanded');
                    toggleIcon.classList.toggle('collapsed');
                });
                
                nodeHeader.appendChild(toggleIcon);
            } else {
                const spacer = document.createElement('span');
                spacer.className = 'branch-toggle-icon';
                nodeHeader.appendChild(spacer);
            }
            
            // ËäÇÁÇπÂÜÖÂÆπ
            const contentDiv = document.createElement('div');
            contentDiv.className = 'branch-node-content';
            
            const labelDiv = document.createElement('div');
            labelDiv.className = 'branch-node-label';
            labelDiv.textContent = `${node.sender === 'user' ? 'üë§' : 'ü§ñ'} ${node.text.substring(0, 50)}${node.text.length > 50 ? '...' : ''}`;
            
            contentDiv.appendChild(labelDiv);
            
            nodeHeader.addEventListener('click', (e) => {
                e.stopPropagation();
                switchToBranch(node.id);
                closeBranchPanel();
            });
            
            nodeHeader.appendChild(contentDiv);
            nodeEl.appendChild(nodeHeader);
            
            if (childrenDiv) {
                nodeEl.appendChild(childrenDiv);
            }
            
            return nodeEl;
        }
        
        // ========== ÂàÜÊîØÂàáÊç¢ ==========
        function switchToBranch(targetNodeId) {
            if (!messageTree[targetNodeId]) return;

            const newPath = [];
            let currentId = targetNodeId;

            while (currentId !== null) {
                newPath.unshift(currentId);
                const node = messageTree[currentId];
                currentId = node.parentId;
            }

            currentPathIds = newPath;
            // ÂàÜÊîØÂêëÈáèÂ∫ìÂ∑≤ÂΩªÂ∫ïÈöîÁ¶ªÔºåÊó†ÈúÄËµãÂÄºÂÖ®Â±ÄÂèòÈáè
            renderCurrentBranch();
            updateVectorDBInfo();  // Êõ¥Êñ∞ÂêëÈáèÂ∫ìÁä∂ÊÄÅÊòæÁ§∫
        }
        
        // ========== Ê∏≤ÊüìÂΩìÂâçÂàÜÊîØ ==========
        function renderCurrentBranch() {
            chatBox.innerHTML = '';
            
            currentPathIds.forEach(nodeId => {
                const node = messageTree[nodeId];
                if (node) {
                    renderMessageElement(node);
                }
            });
            
            chatBox.scrollTop = chatBox.scrollHeight;
        }
        
        function renderMessageElement(node) {
            const wrapper = document.createElement('div');
            wrapper.className = 'message-wrapper';
            wrapper.id = `msg-${node.id}`;
            wrapper.dataset.nodeId = node.id;
            
            const branchIndicator = document.createElement('div');
            branchIndicator.className = 'branch-indicator';
            if (node.childrenIds.length > 1) {
                branchIndicator.textContent = 'üîÄ';
                branchIndicator.title = `${node.childrenIds.length}‰∏™ÂàÜÊîØ`;
            }
            wrapper.appendChild(branchIndicator);
            
            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'message-content-wrapper';
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${node.sender}`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.textContent = node.text;
            contentDiv.dataset.nodeId = node.id;
            
            messageDiv.appendChild(contentDiv);
            
            const actionsDiv = document.createElement('div');
            actionsDiv.className = node.sender === 'user' ? 'message-actions' : 'ai-message-actions';
            
            const editBtn = document.createElement('button');
            editBtn.className = 'edit-btn';
            editBtn.textContent = '‚úé ÁºñËæë';
            editBtn.onclick = () => editMessage(node.id);
            
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'delete-btn';
            deleteBtn.textContent = '‚úï Âà†Èô§';
            deleteBtn.onclick = () => deleteMessageAndChildren(node.id);
            
            actionsDiv.appendChild(editBtn);
            actionsDiv.appendChild(deleteBtn);
            messageDiv.appendChild(actionsDiv);
            
            contentWrapper.appendChild(messageDiv);
            
            if (node.childrenIds.length > 1) {
                const branchInfo = document.createElement('div');
                branchInfo.className = 'branch-info';
                branchInfo.textContent = `‚úì ÂàÜÊîØÁÇπ (${node.childrenIds.length}‰∏™ÂàÜÊîØ)`;
                contentWrapper.appendChild(branchInfo);
            }
            
            wrapper.appendChild(contentWrapper);
            chatBox.appendChild(wrapper);
        }
        
        // ========== Ê∂àÊÅØÁºñËæë ==========
        function editMessage(nodeId) {
            const node = messageTree[nodeId];
            if (!node) return;
            
            const messageEl = document.getElementById(`msg-${nodeId}`);
            if (!messageEl) return;
            
            const contentDiv = messageEl.querySelector('.message-content');
            const actionsDiv = messageEl.querySelector('.message-actions, .ai-message-actions');
            
            if (actionsDiv) actionsDiv.style.display = 'none';
            
            const originalText = contentDiv.textContent;
            
            const editModeDiv = document.createElement('div');
            editModeDiv.className = 'edit-mode';
            
            const editInput = document.createElement('input');
            editInput.type = 'text';
            editInput.className = 'edit-input';
            editInput.value = originalText;
            
            const confirmBtn = document.createElement('button');
            confirmBtn.className = 'edit-btn-small';
            confirmBtn.textContent = node.sender === 'user' ? 'ÂàõÂª∫ÂàÜÊîØ' : '‰øùÂ≠ò‰øÆÊîπ';
            confirmBtn.onclick = () => confirmEdit(nodeId, editInput.value);
            
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'cancel-btn-small';
            cancelBtn.textContent = 'ÂèñÊ∂à';
            cancelBtn.onclick = () => cancelEdit(nodeId);
            
            editModeDiv.appendChild(editInput);
            editModeDiv.appendChild(confirmBtn);
            editModeDiv.appendChild(cancelBtn);
            
            contentDiv.style.display = 'none';
            messageEl.appendChild(editModeDiv);
            editInput.focus();
            editInput.select();
        }
        
        // ========== Á°ÆËÆ§ÁºñËæë ==========
        async function confirmEdit(nodeId, newText) {
            if (!newText.trim()) return;
            
            const originalNode = messageTree[nodeId];
            if (!originalNode) return;
            
            const messageEl = document.getElementById(`msg-${nodeId}`);
            if (!messageEl) return;
            
            const contentDiv = messageEl.querySelector('.message-content');
            const editModeDiv = messageEl.querySelector('.edit-mode');
            const actionsDiv = messageEl.querySelector('.message-actions, .ai-message-actions');
            
            contentDiv.style.display = 'block';
            if (editModeDiv) editModeDiv.remove();
            if (actionsDiv) actionsDiv.style.display = 'none';
            
            if (newText === originalNode.text) {
                if (actionsDiv) actionsDiv.style.display = 'block';
                return;
            }
            
            if (originalNode.sender === 'user') {
                const newNodeId = nodeIdCounter++;
                const newNode = new MessageNode(newNodeId, newText, 'user', originalNode.parentId);
                messageTree[newNodeId] = newNode;
                
                if (originalNode.parentId !== null && messageTree[originalNode.parentId]) {
                    messageTree[originalNode.parentId].childrenIds.push(newNodeId);
                }
                
                currentPathIds = [];
                let currentId = newNodeId;
                while (currentId !== null) {
                    currentPathIds.unshift(currentId);
                    const node = messageTree[currentId];
                    currentId = node.parentId;
                }
                
                deleteAfterNode(nodeId);
                renderCurrentBranch();
                saveData();
                
                await generateNextResponse(newNodeId);
            } else {
                const newNodeId = nodeIdCounter++;
                const newNode = new MessageNode(newNodeId, newText, 'ai', originalNode.parentId);
                messageTree[newNodeId] = newNode;
                
                if (originalNode.parentId !== null && messageTree[originalNode.parentId]) {
                    messageTree[originalNode.parentId].childrenIds.push(newNodeId);
                }
                
                currentPathIds = [];
                let currentId = newNodeId;
                while (currentId !== null) {
                    currentPathIds.unshift(currentId);
                    const node = messageTree[currentId];
                    currentId = node.parentId;
                }
                
                renderCurrentBranch();
                saveData();
            }
        }
        
        function cancelEdit(nodeId) {
            const messageEl = document.getElementById(`msg-${nodeId}`);
            if (!messageEl) return;
            
            const contentDiv = messageEl.querySelector('.message-content');
            const editModeDiv = messageEl.querySelector('.edit-mode');
            const actionsDiv = messageEl.querySelector('.message-actions, .ai-message-actions');
            
            contentDiv.style.display = 'block';
            if (editModeDiv) editModeDiv.remove();
            if (actionsDiv) actionsDiv.style.display = 'block';
        }
        
        // ========== Âà†Èô§Ê∂àÊÅØ ==========
        function deleteAfterNode(nodeId) {
            const nodeIndex = currentPathIds.indexOf(nodeId);
            if (nodeIndex === -1) return;
            
            const nodesToDelete = currentPathIds.slice(nodeIndex + 1);
            currentPathIds = currentPathIds.slice(0, nodeIndex + 1);
            
            nodesToDelete.forEach(id => {
                deleteNodeRecursive(id);
            });
        }
        
        function deleteNodeRecursive(nodeId) {
            const node = messageTree[nodeId];
            if (!node) return;
            
            const childrenIds = [...node.childrenIds];
            childrenIds.forEach(childId => {
                deleteNodeRecursive(childId);
            });
            
            if (node.parentId !== null && messageTree[node.parentId]) {
                const parent = messageTree[node.parentId];
                parent.childrenIds = parent.childrenIds.filter(id => id !== nodeId);
            }
            
            delete messageTree[nodeId];
        }
        
        function deleteMessageAndChildren(nodeId) {
            if (!confirm('Âà†Èô§Ê≠§Ê∂àÊÅØÂèä‰πãÂêéÁöÑÊâÄÊúâÂØπËØùÔºü')) return;
            
            const node = messageTree[nodeId];
            if (!node) return;
            
            deleteNodeRecursive(nodeId);
            
            const nodeIndex = currentPathIds.indexOf(nodeId);
            if (nodeIndex !== -1) {
                currentPathIds = currentPathIds.slice(0, nodeIndex);
            }
            
            renderCurrentBranch();
            saveData();
        }
        
        // ========== ÁîüÊàêÂõûÂ§ç ==========
        async function generateNextResponse(afterNodeId) {
            if (isGenerating) return;
            isGenerating = true;
            sendBtn.disabled = true;

            try {
                const contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';
                contentDiv.innerHTML = '<span class="loading"></span>ÊÄùËÄÉ‰∏≠...';

                const aiNodeId = nodeIdCounter++;
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message ai';
                messageDiv.id = `msg-${aiNodeId}`;
                messageDiv.appendChild(contentDiv);

                const wrapper = document.createElement('div');
                wrapper.className = 'message-wrapper';
                wrapper.id = `msg-wrapper-${aiNodeId}`;

                const branchIndicator = document.createElement('div');
                branchIndicator.className = 'branch-indicator';
                wrapper.appendChild(branchIndicator);

                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'message-content-wrapper';
                contentWrapper.appendChild(messageDiv);
                wrapper.appendChild(contentWrapper);

                chatBox.appendChild(wrapper);
                chatBox.scrollTop = chatBox.scrollHeight;

                let fullPrompt = '';
                const systemPrompt = systemPromptEl.value.trim();

                if (systemPrompt) {
                    fullPrompt = systemPrompt + '\n\n';
                }

                // Ëé∑ÂèñÂΩìÂâçÁî®Êà∑Ê∂àÊÅØ
                const lastUserMessage = currentPathIds
                    .reverse()
                    .find(nodeId => messageTree[nodeId]?.sender === 'user');
                currentPathIds.reverse(); // ÊÅ¢Â§çÈ°∫Â∫è

                // Ê∑ªÂä†ÈïøÊúüËÆ∞ÂøÜ‰∏ä‰∏ãÊñá
                if (lastUserMessage) {
                    const userText = messageTree[lastUserMessage]?.text;
                    const memoryContext = getMemoryContext(userText, 3);
                    if (memoryContext) {
                        fullPrompt += memoryContext + '\n\n';
                    }
                }

                // Ê∑ªÂä†ÂΩìÂâçÂØπËØùÂéÜÂè≤
                currentPathIds.forEach(nodeId => {
                    const node = messageTree[nodeId];
                    if (node && node.sender === 'user') {
                        fullPrompt += `Áî®Êà∑: ${node.text}\n`;
                    }
                });

                const response = await fetch(OLLAMA_API, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: MODEL,
                        prompt: fullPrompt,
                        stream: true,
                        temperature: parseFloat(temperatureEl.value),
                        top_p: parseFloat(topPEl.value),
                        top_k: parseInt(topKEl.value),
                        repeat_penalty: parseFloat(repeatPenaltyEl.value)
                    })
                });

                if (!response.ok) {
                    throw new Error(`APIÈîôËØØ: ${response.status}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let aiResponse = '';

                while (true) {
                    const {done, value} = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.trim()) {
                            try {
                                const json = JSON.parse(line);
                                if (json.response) {
                                    aiResponse += json.response;
                                    contentDiv.textContent = aiResponse;
                                    chatBox.scrollTop = chatBox.scrollHeight;
                                }
                            } catch (e) {
                                // ÂøΩÁï•JSONËß£ÊûêÈîôËØØ
                            }
                        }
                    }
                }

                const aiNode = new MessageNode(aiNodeId, aiResponse, 'ai', afterNodeId);
                messageTree[aiNodeId] = aiNode;

                const afterNode = messageTree[afterNodeId];
                if (afterNode) {
                    afterNode.childrenIds.push(aiNodeId);
                }

                currentPathIds.push(aiNodeId);

                // Â∞ÜÊ∂àÊÅØÊ∑ªÂä†Âà∞ÂΩìÂâçÂàÜÊîØÁöÑÂêëÈáèÂ∫ì
                const vectorDB = getCurrentVectorDB();
                currentPathIds.forEach(nodeId => {
                    const node = messageTree[nodeId];
                    if (node && !vectorDB.vectors[nodeId]) {
                        vectorDB.addDocument(nodeId, node.text, node.timestamp || Date.now());
                    }
                });

                saveCurrentVectorDB();
                renderCurrentBranch();
                saveData();

            } catch (error) {
                console.error('ÁîüÊàêÈîôËØØ:', error);
                const aiNodeId = nodeIdCounter++;
                const aiNode = new MessageNode(aiNodeId, `‚ùå ÈîôËØØ: ${error.message}`, 'ai', afterNodeId);
                messageTree[aiNodeId] = aiNode;

                const afterNode = messageTree[afterNodeId];
                if (afterNode) {
                    afterNode.childrenIds.push(aiNodeId);
                }

                currentPathIds.push(aiNodeId);
                renderCurrentBranch();
            } finally {
                isGenerating = false;
                sendBtn.disabled = false;
                userInput.focus();
            }
        }
        
        // ========== ËÆæÁΩÆÈ¢ÑËÆæÊèêÁ§∫ËØç ==========
        function setPreset(prompt) {
            systemPromptEl.value = prompt;
        }
        
        // ========== ÂèëÈÄÅÊ∂àÊÅØ ==========
        async function sendMessage() {
            const message = userInput.value.trim();
            if (!message || isGenerating) return;
            
            userInput.value = '';
            sendBtn.disabled = true;
            
            try {
                const userNodeId = nodeIdCounter++;
                let parentId = null;
                
                if (currentPathIds.length > 0) {
                    parentId = currentPathIds[currentPathIds.length - 1];
                }
                
                const userNode = new MessageNode(userNodeId, message, 'user', parentId);
                messageTree[userNodeId] = userNode;
                
                if (parentId !== null && messageTree[parentId]) {
                    messageTree[parentId].childrenIds.push(userNodeId);
                }
                
                currentPathIds.push(userNodeId);
                renderCurrentBranch();
                saveData();
                
                // Ê£ÄÊü•ÊòØÂê¶‰ΩøÁî®ÈìæÊù°ÂØπËØùÔºàÈªòËÆ§ÂêØÁî®Ôºâ
                if (executionSession.useChainByDefault && chainPathConfigs.length > 0) {
                    // ‰ΩøÁî®ÈªòËÆ§ÈìæÊù°Ë∑ØÂæÑ
                    const defaultPath = chainPathBuilder.getDefault();
                    if (defaultPath && defaultPath.chains.length > 0) {
                        // ‰º†ÈÄíÂÆåÊï¥ÁöÑË∑ØÂæÑÈÖçÁΩÆ‰ª•ÊîØÊåÅÊùÉÈôêÂíåÊâßË°åÊ®°Âºè
                        await executeChainPath(defaultPath.chains, userNodeId, defaultPath);
                        chainPathBuilder.recordUsage(defaultPath.id);
                    } else {
                        await generateNextResponse(userNodeId);
                    }
                } else {
                    // ÂõûÈÄÄÂà∞Â∏∏ËßÑÂØπËØù
                    await generateNextResponse(userNodeId);
                }
                
            } catch (error) {
                console.error('ÂèëÈÄÅÈîôËØØ:', error);
                sendBtn.disabled = false;
                userInput.focus();
            }
        }
        
        // ========== ÈìæÊù°Ë∑ØÂæÑÊâßË°åËæÖÂä©ÂáΩÊï∞ ==========
        // Ê†πÊçÆÊâßË°åÊ®°ÂºèÂ∞ÜÈìæÊù°ÂàÜÁªÑ
        function groupChainsByMode(chains, executionModes) {
            if (!executionModes || executionModes.length === 0) {
                // Ê≤°ÊúâÊâßË°åÊ®°ÂºèÊó∂ÔºåÊØèÊù°ÈìæÊù°ÂçïÁã¨‰∏∫‰∏ÄÁªÑÔºàÂêÑÈ°∫Â∫èÊâßË°åÔºâ
                return chains.map(chain => [chain]);
            }

            const groups = [];
            let currentGroup = [chains[0]];

            for (let i = 0; i < executionModes.length && i < chains.length - 1; i++) {
                if (executionModes[i] === 'parallel') {
                    // ÂΩìÂâçÊ®°ÂºèÊòØ'parallel'ÔºåÂ∞Ü‰∏ã‰∏ÄÊù°ÈìæÊù°Âä†ÂÖ•ÂΩìÂâçÁªÑ
                    currentGroup.push(chains[i + 1]);
                } else {
                    // ÂΩìÂâçÊ®°ÂºèÊòØ'sequential'ÔºåÂÆåÊàêÂΩìÂâçÁªÑÔºåÂºÄÂßãÊñ∞ÁªÑ
                    groups.push(currentGroup);
                    currentGroup = [chains[i + 1]];
                }
            }

            // Ê∑ªÂä†ÊúÄÂêé‰∏ÄÁªÑ
            if (currentGroup.length > 0) {
                groups.push(currentGroup);
            }

            return groups;
        }

        // ÊâßË°åÂçïÊù°ÈìæÊù°ÔºåËøîÂõûPromise
        async function executeChainPromise(chainId, userMessage, userNodeId, executionId, groupIndex, chainIndexInGroup, nodePermission = 'normal') {
            const chain = chainManager.getChain(chainId);

            if (!chain) {
                console.warn(`ÈìæÊù° ${chainId} ‰∏çÂ≠òÂú®`);
                return {
                    success: false,
                    chainId,
                    chainName: 'Êú™Áü•',
                    error: 'ÈìæÊù°‰∏çÂ≠òÂú®',
                    input: userMessage,
                    output: ''
                };
            }

            try {
                // ÊùÉÈôêÊ£ÄÊü•ÔºöÊ†πÊçÆËäÇÁÇπÊùÉÈôêÂÜ≥ÂÆöÂèØËÆøÈóÆÁöÑÊï∞ÊçÆ
                let accessibleInput = userMessage;
                if (nodePermission === 'normal') {
                    // ÊôÆÈÄöÊùÉÈôêÔºöÂè™ËÉΩËÆøÈóÆ‰∏ä‰∏Ä‰∏™ËäÇÁÇπÁöÑËæìÂá∫Ôºå‰∏çËÉΩËÆøÈóÆÂéüÂßãÁî®Êà∑ËæìÂÖ•
                    // userMessage Âú®ËøôÈáåÂ∑≤ÁªèÊòØÂâç‰∏Ä‰∏™ËäÇÁÇπÁöÑËæìÂá∫ÔºåÊâÄ‰ª•‰∏çÈúÄË¶ÅÁâπÊÆäÂ§ÑÁêÜ
                } else if (nodePermission === 'advanced') {
                    // È´òÁ∫ßÊùÉÈôêÔºöÂèØ‰ª•ËÆøÈóÆ‰∏ä‰∏Ä‰∏™ËäÇÁÇπÁöÑËæìÂá∫ÂíåÂéüÂßãÁî®Êà∑ËæìÂÖ•
                    // ËøôÂú®ÂÖ∂‰ªñÂú∞ÊñπÂ§ÑÁêÜÔºàÂèØ‰ª•ËÆøÈóÆÂÆåÊï¥‰∏ä‰∏ãÊñáÔºâ
                } else if (nodePermission === 'system') {
                    // Á≥ªÁªüÊùÉÈôêÔºöÂÆåÂÖ®ËÆøÈóÆÔºåÂèØ‰ª•ËØªÂèñÁî®Êà∑ËæìÂÖ•Âíå‰øÆÊîπË∑ØÂæÑ
                    // ËøôÂú®ÂÖ∂‰ªñÂú∞ÊñπÂ§ÑÁêÜÔºàÂèØ‰ª•ËÆøÈóÆÂÆåÊï¥‰∏ä‰∏ãÊñáÂíåË∑ØÂæÑÊéßÂà∂Ôºâ
                }

                // ÊòæÁ§∫Âä†ËΩΩÁä∂ÊÄÅ
                const loadingDiv = document.createElement('div');
                loadingDiv.className = 'message-wrapper';
                loadingDiv.id = `chain-loading-${executionId}-${groupIndex}-${chainIndexInGroup}`;

                const loadingContent = document.createElement('div');
                loadingContent.className = 'message-content-wrapper';

                const loadingMsg = document.createElement('div');
                loadingMsg.className = 'message ai';
                loadingMsg.innerHTML = `<div class="message-content"><span class="loading"></span>ÊâßË°åÈìæÊù° ${chain.name}...`;
                if (nodePermission !== 'normal') {
                    loadingMsg.innerHTML += ` [${nodePermission === 'advanced' ? 'È´òÁ∫ß' : 'Á≥ªÁªü'}]`;
                }
                loadingMsg.innerHTML += `</div>`;

                loadingContent.appendChild(loadingMsg);
                loadingDiv.appendChild(loadingContent);
                chatBox.appendChild(loadingDiv);
                chatBox.scrollTop = chatBox.scrollHeight;

                // ÊâßË°åÈìæÊù°
                const model = configManager.getModel(chain.modelId);
                const prompt = configManager.getPrompt(chain.promptId);

                if (!model || !prompt) {
                    throw new Error(`ÈìæÊù°ÈÖçÁΩÆ‰∏çÂÆåÊï¥`);
                }

                // ÊûÑÂª∫ÊèêÁ§∫ËØç
                let fullPrompt = prompt.content + '\n\n';

                // Ê∑ªÂä†ÂâçÁΩÆ‰∏ä‰∏ãÊñá
                const contextPreview = userMessage.length > 1000
                    ? userMessage.substring(0, 1000) + '\n[ÂÜÖÂÆπËøáÈïøÔºåÂ∑≤Êà™Êñ≠...]'
                    : userMessage;
                fullPrompt += '„ÄêÂâçÁΩÆÂ§ÑÁêÜÁªìÊûú„Äë\n' + contextPreview + '\n\n';

                fullPrompt += '„ÄêÁî®Êà∑ËæìÂÖ•„Äë\n' + userMessage;
                fullPrompt += '\n\nËØ∑Êèê‰æõÁõ¥Êé•„ÄÅÊúâÁî®ÁöÑÂõûÁ≠îÔºö';

                // ‰ªéÊ®°ÂûãÈÖçÁΩÆËé∑ÂèñÁîüÊàêÂèÇÊï∞
                const modelParams = model.config || {
                    temperature: 0.7,
                    top_p: 0.9,
                    top_k: 40,
                    repeat_penalty: 1.1
                };

                console.log(`ÊâßË°åÈìæÊù° ${chain.name}ÔºåÊ®°Âûã ${model.name}ÔºåÊùÉÈôê: ${nodePermission}ÔºåÊèêÁ§∫ËØçÈïøÂ∫¶: ${fullPrompt.length}`);

                // ÊâßË°å API ËØ∑Ê±ÇÔºåÊ∑ªÂä†Ë∂ÖÊó∂ÊéßÂà∂
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000); // 60ÁßíË∂ÖÊó∂

                const response = await fetch(OLLAMA_API, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    signal: controller.signal,
                    body: JSON.stringify({
                        model: MODEL,
                        prompt: fullPrompt,
                        stream: false,
                        temperature: modelParams.temperature,
                        top_p: modelParams.top_p,
                        top_k: modelParams.top_k,
                        repeat_penalty: modelParams.repeat_penalty
                    })
                }).finally(() => clearTimeout(timeoutId));

                if (!response.ok) {
                    throw new Error(`API ËøîÂõûÈîôËØØ ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                if (!data.response) {
                    throw new Error('API Êú™ËøîÂõûÂìçÂ∫îÂÜÖÂÆπ');
                }

                // ÁßªÈô§Âä†ËΩΩÁä∂ÊÄÅ
                const loadingEl = document.getElementById(`chain-loading-${executionId}-${groupIndex}-${chainIndexInGroup}`);
                if (loadingEl) loadingEl.remove();

                return {
                    success: true,
                    chainId,
                    chainName: chain.name,
                    input: userMessage,
                    output: data.response,
                    nodePermission: nodePermission
                };

            } catch (error) {
                console.error(`ÈìæÊù°ÊâßË°åÂ§±Ë¥•: ${chain.name}`, error);

                const loadingEl = document.getElementById(`chain-loading-${executionId}-${groupIndex}-${chainIndexInGroup}`);
                if (loadingEl) {
                    loadingEl.querySelector('.message').innerHTML =
                        `<div class="message-content">‚ùå ${chain.name} ÊâßË°åÂ§±Ë¥•: ${error.message}</div>`;
                }

                return {
                    success: false,
                    chainId,
                    chainName: chain.name,
                    error: error.message || 'Êú™Áü•ÈîôËØØ',
                    input: userMessage,
                    output: '',
                    nodePermission: nodePermission
                };
            }
        }

        // ========== ÈìæÊù°Ë∑ØÂæÑÊâßË°å ==========
        async function executeChainPath(chainPath, userNodeId, pathConfig = null) {
            if (!Array.isArray(chainPath) || chainPath.length === 0) {
                await generateNextResponse(userNodeId);
                return;
            }

            // Â¶ÇÊûúÊèê‰æõ‰∫ÜË∑ØÂæÑÈÖçÁΩÆÔºå‰ΩøÁî®ÂÖ∂‰∏≠ÁöÑËäÇÁÇπÈÖçÁΩÆÔºàÊùÉÈôê„ÄÅÊâßË°åÊ®°ÂºèÁ≠âÔºâ
            let nodeConfigs = [];
            if (pathConfig && pathConfig.nodes) {
                nodeConfigs = pathConfig.nodes;
            } else if (pathConfig && pathConfig.executionModes) {
                // ÂêëÂêéÂÖºÂÆπÔºö‰ªé executionModes ÊûÑÂª∫ËäÇÁÇπÈÖçÁΩÆ
                nodeConfigs = chainPath.map((chainId, idx) => ({
                    chainId,
                    permission: 'normal',
                    executionMode: pathConfig.executionModes[idx - 1] === 'parallel' ? 'parallel' : 'sequential'
                }));
            } else {
                // ÈªòËÆ§ÔºöÊâÄÊúâËäÇÁÇπ‰∏∫ÊôÆÈÄöÊùÉÈôêÔºåÈ°∫Â∫èÊâßË°å
                nodeConfigs = chainPath.map((chainId, idx) => ({
                    chainId,
                    permission: 'normal',
                    executionMode: 'sequential'
                }));
            }

            isGenerating = true;

            try {
                const userNode = messageTree[userNodeId];
                const userMessage = userNode?.text || '';
                
                // ÂàõÂª∫ÈìæÊù°Ë∑ØÂæÑÊâßË°åËÆ∞ÂΩï
                const executionId = `exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                currentChainPathExecution = {
                    id: executionId,
                    pathId: currentChainPathConfig?.id,
                    pathName: currentChainPathConfig?.name || 'ÈìæÊù°ÊâßË°å',
                    startTime: Date.now(),
                    nodes: [],
                    status: 'running'
                };
                chainPathExecutions.push(currentChainPathExecution);

                let context = userMessage;
                let allSucceeded = true;
                let currentIdx = 0;

                // Ê†πÊçÆÊâßË°åÊ®°ÂºèÂ∞ÜÈìæÊù°ÂàÜÁªÑ
                const executionModes = currentChainPathConfig?.executionModes || [];
                const groups = groupChainsByMode(chainPath, executionModes);

                console.log(`ÈìæÊù°Ë∑ØÂæÑÂàÜÁªÑ: ${groups.length} ÁªÑÔºåÊâßË°åÊ®°Âºè:`, executionModes);

                // ÊåâÁªÑÈ°∫Â∫èÊâßË°å - ÊØèÁªÑÂÜÖÈÉ®ÂèØËÉΩÂπ∂Ë°åÊâßË°å
                for (let groupIndex = 0; groupIndex < groups.length; groupIndex++) {
                    const group = groups[groupIndex];
                    console.log(`ÊâßË°åÁ¨¨ ${groupIndex + 1} ÁªÑÔºåÂåÖÂê´ ${group.length} Êù°ÈìæÊù°:`, group);

                    if (group.length === 1) {
                        // ÂçïÈìæÊù°ÔºåÁõ¥Êé•È°∫Â∫èÊâßË°å
                        const chainId = group[0];
                        // ‰ªé nodeConfigs ‰∏≠Ëé∑ÂèñÊ≠§ÈìæÊù°ÁöÑÊùÉÈôê
                        const nodeConfig = nodeConfigs.find(nc => nc.chainId === chainId);
                        const nodePermission = nodeConfig ? nodeConfig.permission : 'normal';

                        const result = await executeChainPromise(chainId, context, userNodeId, executionId, groupIndex, 0, nodePermission);

                        if (result.success) {
                            context = result.output;

                            // ‰∏∫ÂΩìÂâçÈìæÊù°ËäÇÁÇπÂàõÂª∫Áã¨Á´ãÁöÑÂêëÈáèÂ∫ì
                            const nodeVectorDBKey = `${executionId}_${currentIdx}`;
                            const nodeVectorDB = new VectorDatabase();
                            chainNodeVectorDBs[nodeVectorDBKey] = nodeVectorDB;
                            nodeVectorDB.addDocument(`input_${nodeVectorDBKey}`, userMessage, Date.now());
                            nodeVectorDB.addDocument(`output_${nodeVectorDBKey}`, context, Date.now());

                            // ËÆ∞ÂΩïÊâßË°åËäÇÁÇπ‰ø°ÊÅØ
                            currentChainPathExecution.nodes.push({
                                idx: currentIdx,
                                chainId: result.chainId,
                                chainName: result.chainName,
                                input: userMessage,
                                previousOutput: currentIdx > 0 ? (currentChainPathExecution.nodes[currentIdx - 1].output) : null,
                                output: result.output,
                                status: 'success',
                                vectorDBKey: nodeVectorDBKey,
                                model: MODEL,
                                executionTime: Date.now()
                            });
                        } else {
                            allSucceeded = false;
                            currentChainPathExecution.nodes.push({
                                idx: currentIdx,
                                chainId: result.chainId,
                                chainName: result.chainName,
                                input: context,
                                output: '',
                                status: 'failed',
                                error: result.error || 'Êú™Áü•ÈîôËØØ',
                                executionTime: Date.now()
                            });
                        }

                        currentIdx++;

                    } else {
                        // Â§öÈìæÊù°Âπ∂Ë°åÊâßË°å - ‰ΩøÁî®Promise.allSettledÂ§ÑÁêÜ
                        const promises = group.map((chainId, chainIndexInGroup) => {
                            // ‰ªé nodeConfigs ‰∏≠Ëé∑ÂèñÊ≠§ÈìæÊù°ÁöÑÊùÉÈôê
                            const nodeConfig = nodeConfigs.find(nc => nc.chainId === chainId);
                            const nodePermission = nodeConfig ? nodeConfig.permission : 'normal';
                            return executeChainPromise(chainId, context, userNodeId, executionId, groupIndex, chainIndexInGroup, nodePermission);
                        });

                        const results = await Promise.allSettled(promises);

                        // ÂàõÂª∫Âπ∂Ë°åÁªÑÁªìÊûúÁªìÊûÑÔºå‰øùÂ≠òÊâÄÊúâËæìÂá∫
                        const parallelGroupResults = {
                            groupIndex: groupIndex,
                            chainResults: [],
                            allOutputs: {}
                        };

                        // Â§ÑÁêÜÂπ∂Ë°åÊâßË°åÁöÑÁªìÊûú
                        let groupSuccessCount = 0;

                        for (let i = 0; i < results.length; i++) {
                            const result = results[i];
                            const actualResult = result.status === 'fulfilled' ? result.value : null;
                            const nodeIdx = currentIdx + i;  // ‚Üê È¢ÑÂàÜÈÖçÁöÑÂîØ‰∏Ä idx

                            if (actualResult && actualResult.success) {
                                groupSuccessCount++;

                                // ‰øùÂ≠òÊâÄÊúâÊàêÂäüËæìÂá∫Ôºà‰∏çË¶ÜÁõñÔºÅÔºâ
                                parallelGroupResults.chainResults.push({
                                    chainId: actualResult.chainId,
                                    chainName: actualResult.chainName,
                                    output: actualResult.output
                                });
                                parallelGroupResults.allOutputs[actualResult.chainId] = actualResult.output;

                                // ‰∏∫Âπ∂Ë°åÈìæÊù°ÂàõÂª∫ÂêëÈáèÂ∫ì
                                const nodeVectorDBKey = `${executionId}_${nodeIdx}`;
                                const nodeVectorDB = new VectorDatabase();
                                chainNodeVectorDBs[nodeVectorDBKey] = nodeVectorDB;
                                nodeVectorDB.addDocument(`input_${nodeVectorDBKey}`, userMessage, Date.now());
                                nodeVectorDB.addDocument(`output_${nodeVectorDBKey}`, actualResult.output, Date.now());

                                currentChainPathExecution.nodes.push({
                                    idx: nodeIdx,  // ‚Üê ‰ΩøÁî®È¢ÑÂàÜÈÖçÁöÑÂîØ‰∏Äidx
                                    chainId: actualResult.chainId,
                                    chainName: actualResult.chainName,
                                    input: userMessage,
                                    previousOutput: nodeIdx > 0 ? (currentChainPathExecution.nodes[nodeIdx - 1]?.output) : null,
                                    output: actualResult.output,
                                    status: 'success',
                                    vectorDBKey: nodeVectorDBKey,
                                    model: MODEL,
                                    executionTime: Date.now(),
                                    isParallel: true,
                                    groupIndex: groupIndex
                                });
                            } else {
                                allSucceeded = false;
                                const errorMsg = (result.status === 'rejected' ? result.reason : actualResult?.error) || 'Êú™Áü•ÈîôËØØ';

                                currentChainPathExecution.nodes.push({
                                    idx: nodeIdx,  // ‚Üê ‰ΩøÁî®È¢ÑÂàÜÈÖçÁöÑÂîØ‰∏Äidx
                                    chainId: actualResult?.chainId || group[i],
                                    chainName: actualResult?.chainName || 'Êú™Áü•',
                                    input: context,
                                    output: '',
                                    status: 'failed',
                                    error: errorMsg,
                                    executionTime: Date.now(),
                                    isParallel: true,
                                    groupIndex: groupIndex
                                });
                            }
                        }

                        // ‰øùÂ≠òÂπ∂Ë°åÁªÑÁªìÊûúÔºà‰∏∫ÂêéÁª≠ÂàÜÊûê‰ΩøÁî®Ôºâ
                        currentChainPathExecution.parallelGroups = currentChainPathExecution.parallelGroups || [];
                        currentChainPathExecution.parallelGroups.push(parallelGroupResults);

                        // ‚òÖ Ê†∏ÂøÉ‰øÆÂ§çÔºöÂêàÂπ∂ÊâÄÊúâÂπ∂Ë°åËæìÂá∫Âπ∂‰º†ÈÄíÁªô‰∏ã‰∏ÄÁªÑ
                        if (groupSuccessCount > 0) {
                            // Â∞ÜÂêÑ‰∏™ÈìæÊù°ÁöÑËæìÂá∫ÊåâÊ†ºÂºèÂåñÊñπÂºèÂêàÂπ∂
                            const mergedOutput = parallelGroupResults.chainResults
                                .map(result => `„Äê${result.chainName} ËæìÂá∫„Äë\n${result.output}`)
                                .join('\n\n---\n\n');

                            context = mergedOutput;  // ‚Üê ‰º†ÈÄíÂÆåÊï¥ÁöÑÂπ∂Ë°åËæìÂá∫ËÄå‰∏çÊòØÂè™‰º†ÈÄíÊúÄÂêé‰∏Ä‰∏™

                            console.log(`Á¨¨ ${groupIndex + 1} ÁªÑÂπ∂Ë°åÊâßË°åÂÆåÊàê: ${groupSuccessCount}/${group.length} ÊàêÂäüÔºå${parallelGroupResults.chainResults.length} ‰∏™ËæìÂá∫Â∑≤ÂêàÂπ∂`);
                        } else {
                            console.warn(`Á¨¨ ${groupIndex + 1} ÁªÑÂπ∂Ë°åÊâßË°åÂÖ®ÈÉ®Â§±Ë¥•`);
                        }

                        // ÊâπÈáèÈÄíÂ¢û idx
                        currentIdx += group.length;
                    }
                }

                currentChainPathExecution.endTime = Date.now();
                currentChainPathExecution.status = allSucceeded ? 'completed' : 'partial';

                // Ëé∑ÂèñÊúÄÂêé‰∏Ä‰∏™ÊàêÂäüÁöÑËæìÂá∫‰Ωú‰∏∫ÊúÄÁªàÂìçÂ∫î
                const lastSuccessNode = currentChainPathExecution.nodes
                    .slice()
                    .reverse()
                    .find(node => node.status === 'success');
                
                const finalResponse = lastSuccessNode ? lastSuccessNode.output : '';

                // ‰øùÂ≠òÊúÄÁªàÂõûÂ§ç‰∏∫AIËäÇÁÇπ
                if (finalResponse) {
                    const aiNodeId = nodeIdCounter++;
                    const aiNode = new MessageNode(aiNodeId, finalResponse, 'ai', userNodeId);
                    aiNode.executionId = currentChainPathExecution.id;  // ÂÖ≥ËÅîÊâßË°åËÆ∞ÂΩï
                    messageTree[aiNodeId] = aiNode;

                    const userNodeMessage = messageTree[userNodeId];
                    if (userNodeMessage) {
                        userNodeMessage.childrenIds.push(aiNodeId);
                    }

                    currentPathIds.push(aiNodeId);

                    // Â∞ÜÊúÄÁªàÊ∂àÊÅØÊ∑ªÂä†Âà∞ÂΩìÂâçÂàÜÊîØÁöÑÂêëÈáèÂ∫ìÔºà‰∏çÊ∑ªÂä†Âà∞ÈìæÊù°ËäÇÁÇπÁöÑÂêëÈáèÂ∫ìÔºâ
                    const vectorDB = getCurrentVectorDB();
                    [userNodeId, aiNodeId].forEach(nodeId => {
                        const node = messageTree[nodeId];
                        if (node && !vectorDB.vectors[nodeId]) {
                            vectorDB.addDocument(nodeId, node.text, node.timestamp || Date.now());
                        }
                    });

                    saveCurrentVectorDB();
                    renderCurrentBranch();
                    saveData();

                    // ‰øùÂ≠òÊâßË°åËÆ∞ÂΩï
                    saveChainPathExecutions();
                } else {
                    throw new Error('ÊâÄÊúâÈìæÊù°ÊâßË°åÈÉΩÂ§±Ë¥•');
                }

            } catch (error) {
                console.error('ÈìæÊù°Ë∑ØÂæÑÊâßË°åÈîôËØØ:', error);
                const aiNodeId = nodeIdCounter++;
                const aiNode = new MessageNode(aiNodeId, `‚ùå ÈìæÊù°ÊâßË°åÈîôËØØ: ${error.message}`, 'ai', userNodeId);
                messageTree[aiNodeId] = aiNode;

                const userNodeMessage = messageTree[userNodeId];
                if (userNodeMessage) {
                    userNodeMessage.childrenIds.push(aiNodeId);
                }

                currentPathIds.push(aiNodeId);
                renderCurrentBranch();
                saveData();
                
                if (currentChainPathExecution) {
                    currentChainPathExecution.status = 'failed';
                    currentChainPathExecution.endTime = Date.now();
                    saveChainPathExecutions();
                }
            } finally {
                isGenerating = false;
                sendBtn.disabled = false;
                userInput.focus();
            }
        }
        function showVectorDBStats() {
            const vectorDB = getCurrentVectorDB();
            const branchId = getCurrentBranchId();
            const vectorCount = Object.keys(vectorDB.vectors).length;
            const vocabSize = vectorDB.vocabulary.size;
            const totalDocs = vectorDB.totalDocs;
            const branchesCount = Object.keys(branchVectorDBMap).length;

            let statsText = `üìä ÂêëÈáèÂ∫ìÁªüËÆ° (ÂΩìÂâçÂàÜÊîØ: ${branchId}):\n`;
            statsText += `‚îú‚îÄ Â∑≤Á¥¢ÂºïÊ∂àÊÅØ: ${vectorCount}\n`;
            statsText += `‚îú‚îÄ ËØçÊ±áË°®Â§ßÂ∞è: ${vocabSize}\n`;
            statsText += `‚îú‚îÄ ÊñáÊ°£ÊÄªÊï∞: ${totalDocs}\n`;
            statsText += `‚îú‚îÄ ÂàÜÊîØÊï∞: ${branchesCount}\n`;
            statsText += `‚îî‚îÄ Â≠òÂÇ®Â§ßÂ∞è: ${formatBytes(JSON.stringify(vectorDB.export()).length)}`;

            alert(statsText);
            updateVectorDBInfo();
        }

        // ========== ÈìæÊù°ÂØπËØùËÆ∞ÂΩïÊü•ÁúãÂíåÁºñËæë ==========
        function showChainDialogueHistory() {
            if (chainPathExecutions.length === 0) {
                alert('ËøòÊ≤°ÊúâÈìæÊù°ÊâßË°åËÆ∞ÂΩï');
                return;
            }

            let html = 'üîó ÈìæÊù°ÂØπËØùÂéÜÂè≤ËÆ∞ÂΩï\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n';

            chainPathExecutions.forEach((exec, execIdx) => {
                html += `„ÄêÊâßË°å ${execIdx + 1}„Äë ${exec.pathName}\n`;
                html += `Êó∂Èó¥: ${new Date(exec.startTime).toLocaleString()}\n`;
                html += `Áä∂ÊÄÅ: ${exec.status === 'completed' ? '‚úì ÂÆåÊàê' : exec.status === 'partial' ? '‚ö†Ô∏è ÈÉ®ÂàÜÂÆåÊàê' : '‚ùå Â§±Ë¥•'}\n`;
                html += `ËÄóÊó∂: ${Math.round((exec.endTime - exec.startTime) / 1000)}Áßí\n`;
                html += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;

                exec.nodes.forEach((node, nodeIdx) => {
                    html += `\n  [${nodeIdx + 1}] ${node.chainName}\n`;
                    html += `  Áä∂ÊÄÅ: ${node.status === 'success' ? '‚úì' : '‚ùå'} ${node.status}\n`;
                    if (node.error) {
                        html += `  ÈîôËØØ: ${node.error}\n`;
                    }
                    html += `  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
                    html += `  ËæìÂÖ•: ${node.input.substring(0, 100)}${node.input.length > 100 ? '...' : ''}\n`;
                    if (node.previousOutput) {
                        html += `  ÂâçÁΩÆËæìÂá∫: ${node.previousOutput.substring(0, 50)}...\n`;
                    }
                    html += `  ËæìÂá∫: ${node.output.substring(0, 100)}${node.output.length > 100 ? '...' : ''}\n`;
                });

                html += '\n\n';
            });

            html += '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n';
            html += `ÊÄªÊâßË°åÊï∞: ${chainPathExecutions.length}\n`;

            // ÂàõÂª∫Ê®°ÊÄÅÁ™óÂè£ÊòæÁ§∫
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center;
                z-index: 5000;
            `;

            const content = document.createElement('div');
            content.style.cssText = `
                background: white; border-radius: 12px; padding: 24px; max-width: 800px; max-height: 80vh;
                overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            `;

            const title = document.createElement('h2');
            title.style.cssText = 'margin: 0 0 16px 0; color: #333;';
            title.textContent = 'üîó ÈìæÊù°ÊâßË°åËÆ∞ÂΩï';

            const textArea = document.createElement('textarea');
            textArea.value = html;
            textArea.style.cssText = `
                width: 100%; height: 400px; padding: 12px; border: 1px solid #ddd;
                border-radius: 6px; font-family: monospace; font-size: 12px;
                resize: vertical;
            `;

            const detailBtn = document.createElement('button');
            detailBtn.textContent = 'Êü•ÁúãËØ¶ÁªÜ';
            detailBtn.style.cssText = `
                margin-top: 12px; margin-right: 8px; padding: 8px 16px;
                background: #667eea; color: white; border: none; border-radius: 6px;
                cursor: pointer; font-size: 12px;
            `;
            detailBtn.onclick = () => showChainDialogueDetailed();

            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'ÂÖ≥Èó≠';
            closeBtn.style.cssText = `
                margin-top: 12px; padding: 8px 16px;
                background: #999; color: white; border: none; border-radius: 6px;
                cursor: pointer; font-size: 12px;
            `;
            closeBtn.onclick = () => modal.remove();

            const buttonDiv = document.createElement('div');
            buttonDiv.style.cssText = 'margin-top: 16px;';
            buttonDiv.appendChild(detailBtn);
            buttonDiv.appendChild(closeBtn);

            content.appendChild(title);
            content.appendChild(textArea);
            content.appendChild(buttonDiv);
            modal.appendChild(content);
            document.body.appendChild(modal);
        }

        function showChainDialogueDetailed() {
            // ÊòæÁ§∫ÊúÄÁªÜËá¥ÁöÑÂØπËØù‰∫§‰∫íÁïåÈù¢
            const lastExec = chainPathExecutions[chainPathExecutions.length - 1];
            
            if (!lastExec) {
                alert('Ê≤°ÊúâÊâßË°åËÆ∞ÂΩï');
                return;
            }

            // ÂàõÂª∫Ê®°ÊÄÅÁ™óÂè£ÊòæÁ§∫
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center;
                z-index: 5000; overflow-y: auto; padding: 20px;
            `;

            const content = document.createElement('div');
            content.style.cssText = `
                background: white; border-radius: 12px; box-shadow: 0 20px 60px rgba(0,0,0,0.5);
                max-width: 1000px; width: 100%; max-height: 90vh; overflow-y: auto;
            `;

            // Ê†áÈ¢òÊ†è
            const titleBar = document.createElement('div');
            titleBar.style.cssText = `
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white; padding: 20px; border-radius: 12px 12px 0 0;
                display: flex; justify-content: space-between; align-items: center;
            `;

            const title = document.createElement('h2');
            title.style.cssText = 'margin: 0; font-size: 18px;';
            title.textContent = `üîó ${lastExec.pathName} - ÈìæË∑ØÂØπËØùËØ¶ÊÉÖ`;

            const execTime = document.createElement('div');
            execTime.style.cssText = 'font-size: 12px; opacity: 0.9;';
            execTime.textContent = new Date(lastExec.startTime).toLocaleString();

            titleBar.appendChild(title);
            titleBar.appendChild(execTime);
            content.appendChild(titleBar);

            // ÂØπËØùÂÜÖÂÆπ
            const dialogueContainer = document.createElement('div');
            dialogueContainer.style.cssText = 'padding: 20px;';

            lastExec.nodes.forEach((node, idx) => {
                const nodeDiv = document.createElement('div');
                nodeDiv.style.cssText = `
                    margin-bottom: 20px; border-radius: 8px; overflow: hidden;
                    border: 2px solid #f0f0f0;
                `;

                // ËäÇÁÇπÂ§¥ÈÉ®
                const header = document.createElement('div');
                header.style.cssText = `
                    background: linear-gradient(90deg, #f0f7ff 0%, #e6f2ff 100%);
                    padding: 12px 16px; border-bottom: 2px solid #d0e0ff;
                    display: flex; justify-content: space-between; align-items: center;
                `;

                const headerLeft = document.createElement('div');
                headerLeft.style.cssText = 'display: flex; align-items: center; gap: 10px;';
                
                const stepLabel = document.createElement('span');
                stepLabel.style.cssText = `
                    background: #667eea; color: white; border-radius: 50%;
                    width: 28px; height: 28px; display: flex; align-items: center;
                    justify-content: center; font-weight: bold; font-size: 12px;
                `;
                stepLabel.textContent = idx + 1;

                const chainName = document.createElement('span');
                chainName.style.cssText = 'font-weight: bold; color: #333; font-size: 14px;';
                chainName.textContent = `${node.chainName}`;

                headerLeft.appendChild(stepLabel);
                headerLeft.appendChild(chainName);

                const statusBadge = document.createElement('span');
                statusBadge.style.cssText = `
                    padding: 4px 12px; border-radius: 4px; font-size: 11px; font-weight: bold;
                    ${node.status === 'success' 
                        ? 'background: #d4edda; color: #155724;' 
                        : 'background: #f8d7da; color: #721c24;'
                    }
                `;
                statusBadge.textContent = node.status === 'success' ? '‚úì ÊàêÂäü' : '‚ùå Â§±Ë¥•';

                header.appendChild(headerLeft);
                header.appendChild(statusBadge);
                nodeDiv.appendChild(header);

                // ÂØπËØùÂÜÖÂÆπ
                const body = document.createElement('div');
                body.style.cssText = 'padding: 16px; background: white;';

                // Áî®Êà∑ËæìÂÖ•
                const inputSection = document.createElement('div');
                inputSection.style.cssText = 'margin-bottom: 16px;';
                
                const inputLabel = document.createElement('div');
                inputLabel.style.cssText = `
                    font-size: 12px; font-weight: bold; color: #667eea;
                    margin-bottom: 8px; text-transform: uppercase;
                `;
                inputLabel.textContent = 'üë§ Áî®Êà∑ËæìÂÖ•';

                const inputContent = document.createElement('div');
                inputContent.style.cssText = `
                    background: #f9f9f9; padding: 12px; border-radius: 6px;
                    border-left: 3px solid #667eea; font-size: 13px; color: #333;
                    line-height: 1.6; word-wrap: break-word;
                `;
                inputContent.textContent = node.input;

                inputSection.appendChild(inputLabel);
                inputSection.appendChild(inputContent);
                body.appendChild(inputSection);

                // ÂâçÁΩÆËæìÂá∫ÔºàÂ¶ÇÊûúÊúâÔºâ
                if (node.previousOutput) {
                    const prevSection = document.createElement('div');
                    prevSection.style.cssText = 'margin-bottom: 16px;';
                    
                    const prevLabel = document.createElement('div');
                    prevLabel.style.cssText = `
                        font-size: 12px; font-weight: bold; color: #764ba2;
                        margin-bottom: 8px; text-transform: uppercase;
                    `;
                    prevLabel.textContent = '‚¨ÖÔ∏è  ÂâçÁΩÆÂ§ÑÁêÜÁªìÊûú';

                    const prevContent = document.createElement('div');
                    prevContent.style.cssText = `
                        background: #f0e6ff; padding: 12px; border-radius: 6px;
                        border-left: 3px solid #764ba2; font-size: 13px; color: #333;
                        line-height: 1.6; word-wrap: break-word;
                    `;
                    prevContent.textContent = node.previousOutput;

                    prevSection.appendChild(prevLabel);
                    prevSection.appendChild(prevContent);
                    body.appendChild(prevSection);
                }

                // ËæìÂá∫ÁªìÊûú
                if (node.output) {
                    const outputSection = document.createElement('div');
                    outputSection.style.cssText = 'margin-bottom: 16px;';
                    
                    const outputLabel = document.createElement('div');
                    outputLabel.style.cssText = `
                        font-size: 12px; font-weight: bold; color: #28a745;
                        margin-bottom: 8px; text-transform: uppercase;
                    `;
                    outputLabel.textContent = 'ü§ñ Ê®°ÂûãËæìÂá∫';

                    const outputContent = document.createElement('div');
                    outputContent.style.cssText = `
                        background: #f0fff4; padding: 12px; border-radius: 6px;
                        border-left: 3px solid #28a745; font-size: 13px; color: #333;
                        line-height: 1.8; word-wrap: break-word;
                    `;
                    outputContent.textContent = node.output;

                    outputSection.appendChild(outputLabel);
                    outputSection.appendChild(outputContent);
                    body.appendChild(outputSection);
                } else if (node.error) {
                    const errorSection = document.createElement('div');
                    errorSection.style.cssText = 'margin-bottom: 16px;';
                    
                    const errorLabel = document.createElement('div');
                    errorLabel.style.cssText = `
                        font-size: 12px; font-weight: bold; color: #dc3545;
                        margin-bottom: 8px; text-transform: uppercase;
                    `;
                    errorLabel.textContent = '‚ùå ÈîôËØØ‰ø°ÊÅØ';

                    const errorContent = document.createElement('div');
                    errorContent.style.cssText = `
                        background: #ffe6e6; padding: 12px; border-radius: 6px;
                        border-left: 3px solid #dc3545; font-size: 13px; color: #721c24;
                    `;
                    errorContent.textContent = node.error;

                    errorSection.appendChild(errorLabel);
                    errorSection.appendChild(errorContent);
                    body.appendChild(errorSection);
                }

                // ÂÖÉÊï∞ÊçÆ
                const metadata = document.createElement('div');
                metadata.style.cssText = `
                    font-size: 11px; color: #999; padding-top: 12px;
                    border-top: 1px solid #eee; display: flex; gap: 16px;
                `;
                metadata.innerHTML = `
                    <span>‚è±Ô∏è ${Math.round((node.executionTime - lastExec.startTime) / 1000)}s</span>
                    <span>üìä Ê®°Âûã: ${node.model}</span>
                `;

                body.appendChild(metadata);
                nodeDiv.appendChild(body);
                dialogueContainer.appendChild(nodeDiv);
            });

            content.appendChild(dialogueContainer);

            // Â∫ïÈÉ®ÊåâÈíÆÊ†è
            const footer = document.createElement('div');
            footer.style.cssText = `
                padding: 16px 20px; background: #f9f9f9;
                border-top: 1px solid #eee; display: flex; gap: 8px;
                justify-content: flex-end;
            `;

            const copyBtn = document.createElement('button');
            copyBtn.textContent = 'üìã Â§çÂà∂ÂÖ®ÈÉ®';
            copyBtn.style.cssText = `
                padding: 8px 16px; background: #667eea; color: white;
                border: none; border-radius: 6px; cursor: pointer; font-size: 12px;
            `;
            copyBtn.onclick = () => {
                let text = `${lastExec.pathName} - ÈìæË∑ØÂØπËØùËØ¶ÊÉÖ\n`;
                text += `Êó∂Èó¥: ${new Date(lastExec.startTime).toLocaleString()}\n`;
                text += '‚îÅ'.repeat(50) + '\n\n';

                lastExec.nodes.forEach((node, idx) => {
                    text += `„ÄêÁ¨¨${idx + 1}Ê≠•„Äë${node.chainName} ${node.status === 'success' ? '‚úì' : '‚ùå'}\n`;
                    text += `ËæìÂÖ•: ${node.input}\n`;
                    if (node.previousOutput) text += `ÂâçÁΩÆ: ${node.previousOutput}\n`;
                    text += `ËæìÂá∫: ${node.output || node.error}\n`;
                    text += '‚îÄ'.repeat(50) + '\n\n';
                });

                navigator.clipboard.writeText(text).then(() => {
                    showSaveIndicator('‚úì Â∑≤Â§çÂà∂');
                });
            };

            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'ÂÖ≥Èó≠';
            closeBtn.style.cssText = `
                padding: 8px 16px; background: #999; color: white;
                border: none; border-radius: 6px; cursor: pointer; font-size: 12px;
            `;
            closeBtn.onclick = () => modal.remove();

            footer.appendChild(copyBtn);
            footer.appendChild(closeBtn);
            content.appendChild(footer);

            modal.appendChild(content);
            document.body.appendChild(modal);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function updateVectorDBInfo() {
            const infoDiv = document.getElementById('vectorDBInfo');
            if (!infoDiv) return;

            const vectorDB = getCurrentVectorDB();
            const branchId = getCurrentBranchId();
            const vectorCount = Object.keys(vectorDB.vectors).length;
            const vocabSize = vectorDB.vocabulary.size;
            const branchesCount = Object.keys(branchVectorDBMap).length;

            if (vectorCount === 0) {
                infoDiv.innerHTML = `
                    <div style="line-height: 1.6;">
                        <strong>üß† ÂêëÈáèÂ∫ìÁä∂ÊÄÅ</strong><br>
                        ‚îú‚îÄ ÂàÜÊîØ: <strong>${branchId}</strong><br>
                        ‚îú‚îÄ Ê∂àÊÅØÊï∞: 0<br>
                        ‚îî‚îÄ üì≠ Ê≠§ÂàÜÊîØ‰∏∫Á©∫
                    </div>
                `;
            } else {
                infoDiv.innerHTML = `
                    <div style="line-height: 1.6;">
                        <strong>üß† ÂêëÈáèÂ∫ìÁä∂ÊÄÅ</strong><br>
                        ‚îú‚îÄ ÂàÜÊîØ: <strong>${branchId}</strong><br>
                        ‚îú‚îÄ Ê∂àÊÅØÊï∞: <strong>${vectorCount}</strong><br>
                        ‚îú‚îÄ ËØçÊ±áÈáè: <strong>${vocabSize}</strong><br>
                        ‚îú‚îÄ ÂàÜÊîØÊÄªÊï∞: ${branchesCount}<br>
                        ‚îî‚îÄ Â∞±Áª™
                    </div>
                `;
            }
        }

        function optimizeVectorDB() {
            if (!confirm('‰ºòÂåñÂΩìÂâçÂàÜÊîØÁöÑÂêëÈáèÂ∫ìÂ∞ÜÈáçÊñ∞ËÆ°ÁÆóÊâÄÊúâÂêëÈáèÔºåÁ°ÆËÆ§ÁªßÁª≠Ôºü')) return;

            try {
                const vectorDB = getCurrentVectorDB();
                vectorDB.recomputeAllVectors();
                saveCurrentVectorDB();
                showSaveIndicator('‚úì ‰ºòÂåñÂÆåÊàê');
                updateVectorDBInfo();
            } catch (error) {
                console.error('‰ºòÂåñÂ§±Ë¥•:', error);
                showSaveIndicator('‚úó ‰ºòÂåñÂ§±Ë¥•');
            }
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        // ========== ÈÖçÁΩÆ‰∏≠ÂøÉ UI ÁÆ°ÁêÜ ==========

        // ÈÖçÁΩÆ‰∏≠ÂøÉÈù¢ÊùøÊéßÂà∂
        function toggleConfigCenter() {
            const panel = document.getElementById('configCenterPanel');
            const overlay = document.getElementById('configCenterOverlay');
            panel.classList.toggle('active');
            overlay.classList.toggle('active');
            if (panel.classList.contains('active')) {
                renderConfigCenter();
            }
        }

        function closeConfigCenter() {
            const panel = document.getElementById('configCenterPanel');
            const overlay = document.getElementById('configCenterOverlay');
            panel.classList.remove('active');
            overlay.classList.remove('active');
        }

        function switchConfigTab(tabName) {
            // ÈöêËóèÊâÄÊúâÊ†áÁ≠æÈ°µÂÜÖÂÆπ
            document.querySelectorAll('.config-section').forEach(el => {
                el.classList.remove('active');
            });

            // ÁßªÈô§ÊâÄÊúâÊ†áÁ≠æÊåâÈíÆÁöÑactiveÁ±ª
            document.querySelectorAll('.config-tab').forEach(el => {
                el.classList.remove('active');
            });

            // ÊòæÁ§∫ÈÄâ‰∏≠ÁöÑÊ†áÁ≠æÈ°µ
            const sectionId = {
                'models': 'modelsSection',
                'prompts': 'promptsSection',
                'memories': 'memoriesSection',
                'chains': 'chainsSection',
                'paths': 'chainPathsSection',
                'routes': 'routesSection'
            }[tabName];

            // ‰∏∫ÂØπÂ∫îÁöÑÊ†áÁ≠æÊåâÈíÆÊ∑ªÂä†activeÁ±ª
            const tabButtons = document.querySelectorAll('.config-tab');
            const tabNameMap = {
                'models': 0,
                'prompts': 1,
                'memories': 2,
                'chains': 3,
                'paths': 4,
                'routes': 5
            };
            if (tabNameMap[tabName] !== undefined) {
                tabButtons[tabNameMap[tabName]].classList.add('active');
            }

            const section = document.getElementById(sectionId);
            if (section) {
                section.classList.add('active');
                renderConfigTab(tabName);
            }
        }

        function renderConfigCenter() {
            renderConfigTab('models');
        }

        function renderConfigTab(tabName) {
            const renderFunctions = {
                'models': renderModelsTab,
                'prompts': renderPromptsTab,
                'memories': renderMemoriesTab,
                'chains': renderChainsTab,
                'paths': renderChainPathsTab,
                'routes': renderRoutesTab
            };

            if (renderFunctions[tabName]) {
                renderFunctions[tabName]();
            }
        }

        // ========== Ê®°Âùó1ÔºöÊ®°ÂûãÁÆ°ÁêÜ ==========
        function renderModelsTab() {
            const section = document.getElementById('modelsSection');
            let html = '<h3>üìã Ê®°ÂûãÁÆ°ÁêÜ</h3>';

            if (modelConfigs.length === 0) {
                html += '<div class="empty-state"><div class="empty-state-icon">üì≠</div><p>ËøòÊ≤°ÊúâÊ®°Âûã</p></div>';
            } else {
                modelConfigs.forEach(model => {
                    const params = model.parameters || { temperature: 0.7, top_p: 0.9, top_k: 40, repeat_penalty: 1.1 };
                    html += `
                        <div class="config-item">
                            <div class="config-item-header">
                                <div class="config-item-name">${model.name}</div>
                                <div class="config-item-actions">
                                    <button class="config-btn-small" onclick="editModelUI('${model.id}')">ÁºñËæë</button>
                                    <button class="config-btn-small danger" onclick="deleteModel('${model.id}')">Âà†Èô§</button>
                                </div>
                            </div>
                            <div class="config-item-detail">ID: ${model.id}</div>
                            <div class="config-item-detail">Á±ªÂûã: ${model.type}</div>
                            <div class="config-item-detail" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #eee;">
                                <strong style="color: #667eea; font-size: 11px;">ÁîüÊàêÂèÇÊï∞:</strong>
                                <div style="font-size: 11px; color: #666; margin-top: 4px;">
                                    Ê∏©Â∫¶: ${params.temperature} | Top-P: ${params.top_p} | Top-K: ${params.top_k} | ÈáçÂ§çÁΩö: ${params.repeat_penalty}
                                </div>
                            </div>
                        </div>
                    `;
                });
            }

            html += `
                <div class="config-form">
                    <h4 style="margin: 0 0 12px 0; font-size: 13px;">‚ûï Ê∑ªÂä†Êñ∞Ê®°Âûã</h4>
                    <div class="form-group">
                        <label class="form-label">Ê®°ÂûãID</label>
                        <input type="text" class="form-input" id="newModelId" placeholder="e.g., gpt4">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Ê®°ÂûãÂêçÁß∞</label>
                        <input type="text" class="form-input" id="newModelName" placeholder="e.g., GPT-4">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Á±ªÂûã</label>
                        <input type="text" class="form-input" id="newModelType" placeholder="e.g., openai, ollama" value="ollama">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Ê∏©Â∫¶ (Temperature)</label>
                        <input type="number" class="form-input" id="newModelTemp" placeholder="0.7" value="0.7" min="0" max="2" step="0.1">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Top-P</label>
                        <input type="number" class="form-input" id="newModelTopP" placeholder="0.9" value="0.9" min="0" max="1" step="0.1">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Top-K</label>
                        <input type="number" class="form-input" id="newModelTopK" placeholder="40" value="40" min="1" step="1">
                    </div>
                    <div class="form-group">
                        <label class="form-label">ÈáçÂ§çÁΩö (Repeat Penalty)</label>
                        <input type="number" class="form-input" id="newModelRepeatPenalty" placeholder="1.1" value="1.1" min="0.1" max="2" step="0.1">
                    </div>
                    <div class="form-buttons">
                        <button class="form-btn primary" onclick="addNewModel()">Ê∑ªÂä†Ê®°Âûã</button>
                    </div>
                </div>
            `;

            section.innerHTML = html;
        }

        function addNewModel() {
            const id = document.getElementById('newModelId').value.trim();
            const name = document.getElementById('newModelName').value.trim();
            const type = document.getElementById('newModelType').value.trim() || 'ollama';
            const temperature = parseFloat(document.getElementById('newModelTemp').value) || 0.7;
            const top_p = parseFloat(document.getElementById('newModelTopP').value) || 0.9;
            const top_k = parseInt(document.getElementById('newModelTopK').value) || 40;
            const repeat_penalty = parseFloat(document.getElementById('newModelRepeatPenalty').value) || 1.1;

            if (!id || !name) {
                alert('ËØ∑Â°´ÂÜôÂøÖË¶Å‰ø°ÊÅØ');
                return;
            }

            if (modelConfigs.some(m => m.id === id)) {
                alert('ËØ•Ê®°ÂûãIDÂ∑≤Â≠òÂú®');
                return;
            }

            configManager.addModel(id, name, type, {
                temperature,
                top_p,
                top_k,
                repeat_penalty
            });
            
            document.getElementById('newModelId').value = '';
            document.getElementById('newModelName').value = '';
            document.getElementById('newModelTemp').value = '0.7';
            document.getElementById('newModelTopP').value = '0.9';
            document.getElementById('newModelTopK').value = '40';
            document.getElementById('newModelRepeatPenalty').value = '1.1';
            
            renderModelsTab();
            showSaveIndicator('‚úì Ê®°ÂûãÂ∑≤Ê∑ªÂä†');
        }

        function deleteModel(modelId) {
            if (!confirm('Á°ÆÂÆöË¶ÅÂà†Èô§Ê≠§Ê®°ÂûãÂêóÔºü')) return;
            configManager.removeModel(modelId);
            renderModelsTab();
            showSaveIndicator('‚úì Ê®°ÂûãÂ∑≤Âà†Èô§');
        }

        // ========== Ê®°Âùó2ÔºöÊèêÁ§∫ËØçÁÆ°ÁêÜ ==========
        function renderPromptsTab() {
            const section = document.getElementById('promptsSection');
            let html = '<h3>üìù ÊèêÁ§∫ËØçÁÆ°ÁêÜ</h3>';

            if (promptConfigs.length === 0) {
                html += '<div class="empty-state"><div class="empty-state-icon">üì≠</div><p>ËøòÊ≤°ÊúâÊèêÁ§∫ËØç</p></div>';
            } else {
                promptConfigs.forEach(prompt => {
                    const preview = prompt.content.substring(0, 60) + (prompt.content.length > 60 ? '...' : '');
                    html += `
                        <div class="config-item">
                            <div class="config-item-header">
                                <div class="config-item-name">${prompt.name}</div>
                                <div class="config-item-actions">
                                    <button class="config-btn-small" onclick="editPromptUI('${prompt.id}')">ÁºñËæë</button>
                                    <button class="config-btn-small danger" onclick="deletePrompt('${prompt.id}')">Âà†Èô§</button>
                                </div>
                            </div>
                            <div class="config-item-detail" style="max-height: 60px; overflow: hidden;">üìå ${preview}</div>
                        </div>
                    `;
                });
            }

            html += `
                <div class="config-form">
                    <h4 style="margin: 0 0 12px 0; font-size: 13px;">‚ûï Ê∑ªÂä†Êñ∞ÊèêÁ§∫ËØç</h4>
                    <div class="form-group">
                        <label class="form-label">ÊèêÁ§∫ËØçID</label>
                        <input type="text" class="form-input" id="newPromptId" placeholder="e.g., architect">
                    </div>
                    <div class="form-group">
                        <label class="form-label">ÊèêÁ§∫ËØçÂêçÁß∞</label>
                        <input type="text" class="form-input" id="newPromptName" placeholder="e.g., Á≥ªÁªüÊû∂ÊûÑÂ∏à">
                    </div>
                    <div class="form-group">
                        <label class="form-label">ÊèêÁ§∫ËØçÂÜÖÂÆπ</label>
                        <textarea class="form-textarea" id="newPromptContent" placeholder="ËæìÂÖ•ÊèêÁ§∫ËØçÂÜÖÂÆπ..."></textarea>
                    </div>
                    <div class="form-buttons">
                        <button class="form-btn primary" onclick="addNewPrompt()">Ê∑ªÂä†ÊèêÁ§∫ËØç</button>
                    </div>
                </div>
            `;

            section.innerHTML = html;
        }

        function addNewPrompt() {
            const id = document.getElementById('newPromptId').value.trim();
            const name = document.getElementById('newPromptName').value.trim();
            const content = document.getElementById('newPromptContent').value.trim();

            if (!id || !name || !content) {
                alert('ËØ∑Â°´ÂÜôÊâÄÊúâÂøÖË¶Å‰ø°ÊÅØ');
                return;
            }

            if (promptConfigs.some(p => p.id === id)) {
                alert('ËØ•ÊèêÁ§∫ËØçIDÂ∑≤Â≠òÂú®');
                return;
            }

            configManager.addPrompt(id, name, content);
            document.getElementById('newPromptId').value = '';
            document.getElementById('newPromptName').value = '';
            document.getElementById('newPromptContent').value = '';
            renderPromptsTab();
            showSaveIndicator('‚úì ÊèêÁ§∫ËØçÂ∑≤Ê∑ªÂä†');
        }

        function deletePrompt(promptId) {
            if (!confirm('Á°ÆÂÆöË¶ÅÂà†Èô§Ê≠§ÊèêÁ§∫ËØçÂêóÔºü')) return;
            configManager.removePrompt(promptId);
            renderPromptsTab();
            showSaveIndicator('‚úì ÊèêÁ§∫ËØçÂ∑≤Âà†Èô§');
        }

        // ========== Ê®°Âùó3ÔºöËÆ∞ÂøÜÂ∫ìÁÆ°ÁêÜ ==========
        function renderMemoriesTab() {
            const section = document.getElementById('memoriesSection');
            let html = '<h3>üß† ËÆ∞ÂøÜÂ∫ìÁÆ°ÁêÜ</h3>';

            if (memoryDBConfigs.length === 0) {
                html += '<div class="empty-state"><div class="empty-state-icon">üì≠</div><p>ËøòÊ≤°ÊúâËÆ∞ÂøÜÂ∫ì</p></div>';
            } else {
                memoryDBConfigs.forEach(memory => {
                    // ËÆ°ÁÆóËØ•ËÆ∞ÂøÜÂ∫ìË¢´‰ΩøÁî®ÁöÑÊ¨°Êï∞
                    const usageCount = chainConfigs.filter(c => c.memoryDBId === memory.id).length;
                    // ÁªüËÆ°ÂΩìÂâçË∑ØÂæÑ‰∏ãËØ•ËÆ∞ÂøÜÂ∫ìÁöÑÂêëÈáèÊï∞ÔºàÊâÄÊúâÂàÜÊîØÊÄªÂíåÔºâ
                    let vectorCount = 0;
                    const pathData = pathDataMap[currentActivePath];
                    if (pathData) {
                        Object.values(pathData.vectorDBMap).forEach(vdb => {
                            // Âè™ÁªüËÆ°Â±û‰∫éËØ•ËÆ∞ÂøÜÂ∫ìÁöÑÂàÜÊîØÔºàÂ¶ÇÈúÄÊõ¥ÁªÜÁ≤íÂ∫¶ÂèØÊâ©Â±ïÔºâ
                            vectorCount += Object.keys(vdb.vectors || {}).length;
                        });
                    }
                    html += `
                        <div class="config-item">
                            <div class="config-item-header">
                                <div class="config-item-name">${memory.name}
                                    <span style='color:#d373cb;font-size:12px;margin-left:8px;' title='ÂΩìÂâçË∑ØÂæÑ‰∏ãÊâÄÊúâÂàÜÊîØÁöÑÊÄªÂêëÈáèÊï∞'>(${vectorCount} ÂêëÈáè)</span>
                                </div>
                                <div class="config-item-actions">
                                    <button class="config-btn-small" onclick="viewMemoryStats('${memory.id}')">ÁªüËÆ°</button>
                                    <button class="config-btn-small" onclick="showOptimizeMemoryDialog('${memory.id}')" style="background: #fff4e6; color: #d373cb; border: 1px solid #d373cb;">üßπ Ê∏ÖÁêÜ</button>
                                    <button class="config-btn-small danger" onclick="deleteMemoryDB('${memory.id}')">Âà†Èô§</button>
                                </div>
                            </div>
                            <div class="config-item-detail">ID: ${memory.id}</div>
                            <div class="config-item-detail">Ë¢´ ${usageCount} ‰∏™ÈìæÊù°‰ΩøÁî®</div>
                        </div>
                    `;
                });
            }

            html += `
                <div class="config-form">
                    <h4 style="margin: 0 0 12px 0; font-size: 13px;">‚ûï Ê∑ªÂä†Êñ∞ËÆ∞ÂøÜÂ∫ì</h4>
                    <div class="form-group">
                        <label class="form-label">ËÆ∞ÂøÜÂ∫ìID</label>
                        <input type="text" class="form-input" id="newMemoryId" placeholder="e.g., memory-tech">
                    </div>
                    <div class="form-group">
                        <label class="form-label">ËÆ∞ÂøÜÂ∫ìÂêçÁß∞</label>
                        <input type="text" class="form-input" id="newMemoryName" placeholder="e.g., ÊäÄÊúØËÆ®ËÆ∫Â∫ì">
                    </div>
                    <div class="form-buttons">
                        <button class="form-btn primary" onclick="addNewMemory()">Ê∑ªÂä†ËÆ∞ÂøÜÂ∫ì</button>
                    </div>
                </div>
            `;

            section.innerHTML = html;
        }

        function addNewMemory() {
            const id = document.getElementById('newMemoryId').value.trim();
            const name = document.getElementById('newMemoryName').value.trim();

            if (!id || !name) {
                alert('ËØ∑Â°´ÂÜôÂøÖË¶Å‰ø°ÊÅØ');
                return;
            }

            if (memoryDBConfigs.some(m => m.id === id)) {
                alert('ËØ•ËÆ∞ÂøÜÂ∫ìIDÂ∑≤Â≠òÂú®');
                return;
            }

            configManager.addMemoryDB(id, name);
            document.getElementById('newMemoryId').value = '';
            document.getElementById('newMemoryName').value = '';
            renderMemoriesTab();
            showSaveIndicator('‚úì ËÆ∞ÂøÜÂ∫ìÂ∑≤Ê∑ªÂä†');
        }

        function deleteMemoryDB(memoryId) {
            const usageCount = chainConfigs.filter(c => c.memoryDBId === memoryId).length;
            if (usageCount > 0) {
                alert(`Ê≠§ËÆ∞ÂøÜÂ∫ìÊ≠£Âú®Ë¢´ ${usageCount} ‰∏™ÈìæÊù°‰ΩøÁî®ÔºåÊó†Ê≥ïÂà†Èô§`);
                return;
            }

            if (!confirm('Á°ÆÂÆöË¶ÅÂà†Èô§Ê≠§ËÆ∞ÂøÜÂ∫ìÂêóÔºü')) return;

            memoryDBConfigs = memoryDBConfigs.filter(m => m.id !== memoryId);
            saveConfigurations();
            renderMemoriesTab();
            showSaveIndicator('‚úì ËÆ∞ÂøÜÂ∫ìÂ∑≤Âà†Èô§');
        }

        function viewMemoryStats(memoryId) {
            const usageChains = chainConfigs.filter(c => c.memoryDBId === memoryId);
            const stats = `
üìä ËÆ∞ÂøÜÂ∫ìÁªüËÆ°Ôºö
‚îú‚îÄ ËÆ∞ÂøÜÂ∫ìID: ${memoryId}
‚îú‚îÄ ‰ΩøÁî®ÁöÑÈìæÊù°Êï∞: ${usageChains.length}
‚îú‚îÄ ÈìæÊù°ÂàóË°®:
${usageChains.map(c => `   ‚Ä¢ ${c.name} (${c.id})`).join('\n')}
‚îî‚îÄ ÊÄªËÆ°: Â∑≤ÂÖ≥ËÅî ${usageChains.length} ‰∏™ÈìæÊù°
            `;
            alert(stats);
        }

        // ========== Ê®°Âùó4ÔºöÈìæÊù°ÁÆ°ÁêÜ ==========
        function renderChainsTab() {
            const section = document.getElementById('chainsSection');
            let html = '<h3>üîó ÈìæÊù°ÁÆ°ÁêÜ</h3>';

            if (chainConfigs.length === 0) {
                html += '<div class="empty-state"><div class="empty-state-icon">üì≠</div><p>ËøòÊ≤°ÊúâÈìæÊù°</p></div>';
            } else {
                chainConfigs.forEach(chain => {
                    const model = configManager.getModel(chain.modelId);
                    const prompt = configManager.getPrompt(chain.promptId);
                    const memory = configManager.getMemoryDB(chain.memoryDBId);

                    html += `
                        <div class="config-item">
                            <div class="config-item-header">
                                <div class="config-item-name">${chain.name}</div>
                                <div class="config-item-actions">
                                    <button class="config-btn-small" onclick="editChainUI('${chain.id}')">ÁºñËæë</button>
                                    <button class="config-btn-small" onclick="showChainConnections('${chain.id}')">ËøûÊé•</button>
                                    <button class="config-btn-small danger" onclick="deleteChain('${chain.id}')">Âà†Èô§</button>
                                </div>
                            </div>
                            <table class="chain-info-table">
                                <tr><td>ID:</td><td>${chain.id}</td></tr>
                                <tr><td>Ê®°Âûã:</td><td>${model ? model.name : '‚ùå Êú™ÊâæÂà∞'}</td></tr>
                                <tr><td>ÊèêÁ§∫ËØç:</td><td>${prompt ? prompt.name : '‚ùå Êú™ÊâæÂà∞'}</td></tr>
                                <tr><td>ËÆ∞ÂøÜÂ∫ì:</td><td>${memory ? memory.name : '‚ùå Êú™ÊâæÂà∞'}</td></tr>
                                <tr><td>ËøûÊé•:</td><td>${chain.connections.length > 0 ? chain.connections.join(', ') : 'Êó†'}</td></tr>
                            </table>
                        </div>
                    `;
                });
            }

            html += `
                <div class="config-form">
                    <h4 style="margin: 0 0 12px 0; font-size: 13px;">‚ûï ÂàõÂª∫Êñ∞ÈìæÊù°</h4>
                    <div class="form-group">
                        <label class="form-label">ÈìæÊù°ÂêçÁß∞</label>
                        <input type="text" class="form-input" id="newChainName" placeholder="e.g., ‰ª£Á†ÅËØÑÂÆ°ÂÆò">
                    </div>
                    <div class="form-group">
                        <label class="form-label">ÈÄâÊã©Ê®°Âûã</label>
                        <select class="form-input" id="newChainModel">
                            <option value="">-- ÈÄâÊã©Ê®°Âûã --</option>
                            ${modelConfigs.map(m => `<option value="${m.id}">${m.name}</option>`).join('')}
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">ÈÄâÊã©ÊèêÁ§∫ËØç</label>
                        <select class="form-input" id="newChainPrompt">
                            <option value="">-- ÈÄâÊã©ÊèêÁ§∫ËØç --</option>
                            ${promptConfigs.map(p => `<option value="${p.id}">${p.name}</option>`).join('')}
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">ÈÄâÊã©ËÆ∞ÂøÜÂ∫ì</label>
                        <select class="form-input" id="newChainMemory">
                            <option value="">-- ÈÄâÊã©ËÆ∞ÂøÜÂ∫ì --</option>
                            ${memoryDBConfigs.map(m => `<option value="${m.id}">${m.name}</option>`).join('')}
                        </select>
                    </div>
                    <div class="form-buttons">
                        <button class="form-btn primary" onclick="addNewChain()">ÂàõÂª∫ÈìæÊù°</button>
                    </div>
                </div>
            `;

            section.innerHTML = html;
        }

        function addNewChain() {
            const name = document.getElementById('newChainName').value.trim();
            const modelId = document.getElementById('newChainModel').value;
            const promptId = document.getElementById('newChainPrompt').value;
            const memoryId = document.getElementById('newChainMemory').value;

            if (!name || !modelId || !promptId || !memoryId) {
                alert('ËØ∑ÈÄâÊã©ÊâÄÊúâÂøÖË¶ÅÁªÑ‰ª∂');
                return;
            }

            const chainId = `chain_${Date.now()}`;
            chainManager.createChain({
                id: chainId,
                name,
                modelId,
                promptId,
                memoryDBId: memoryId,
                parameters: {
                    temperature: 0.7,
                    top_p: 0.9,
                    top_k: 40,
                    repeat_penalty: 1.1
                }
            });

            document.getElementById('newChainName').value = '';
            document.getElementById('newChainModel').value = '';
            document.getElementById('newChainPrompt').value = '';
            document.getElementById('newChainMemory').value = '';
            renderChainsTab();
            showSaveIndicator('‚úì ÈìæÊù°Â∑≤ÂàõÂª∫');
        }

        function deleteChain(chainId) {
            if (!confirm('Á°ÆÂÆöË¶ÅÂà†Èô§Ê≠§ÈìæÊù°ÂêóÔºü')) return;
            chainManager.deleteChain(chainId);
            renderChainsTab();
            showSaveIndicator('‚úì ÈìæÊù°Â∑≤Âà†Èô§');
        }

        function showChainConnections(chainId) {
            const chain = chainManager.getChain(chainId);
            if (!chain) return;

            const connectionInfo = `
üîó ÈìæÊù°ËøûÊé•ÁÆ°ÁêÜ: ${chain.name}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Ê≠§ÈìæÊù°ËøûÊé•Âà∞‰ª•‰∏ãÈìæÊù°:
${chain.connections.length > 0 ? chain.connections.map(id => {
    const target = chainManager.getChain(id);
    return `‚úì ${target ? target.name : '‚ùå Êú™ÊâæÂà∞'} (${id})`;
}).join('\n') : 'ÔºàÊó†Ôºâ'}

ÂèØÈÄâÊìç‰Ωú:
‚Ä¢ ÈÄöËøáÊéßÂà∂Âè∞Ê∑ªÂä†ËøûÊé•ÔºölinkChains('${chainId}', 'target_chain_id')
‚Ä¢ ÈÄöËøáÊéßÂà∂Âè∞Âà†Èô§ËøûÊé•ÔºöchainManager.disconnectChains('${chainId}', 'target_chain_id')
            `;
            alert(connectionInfo);
        }

        // ========== Ê®°Âùó4.5ÔºöÈìæÊù°Ë∑ØÂæÑÁÆ°ÁêÜ ==========
        function renderChainPathsTab() {
            const section = document.getElementById('chainPathsSection');
            let html = '<h3>üõ£Ô∏è ÈìæÊù°Ë∑ØÂæÑÁÆ°ÁêÜ</h3>';
            
            html += `
                <div class="chain-default-mode" style="background: #f0f7ff; padding: 12px; border-radius: 6px; margin-bottom: 15px; border-left: 3px solid #667eea;">
                    <div style="font-weight: bold; margin-bottom: 8px; color: #667eea;">‚öôÔ∏è ÈªòËÆ§ÂØπËØùÊ®°Âºè</div>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="useChainByDefault" ${executionSession.useChainByDefault ? 'checked' : ''} onchange="toggleChainByDefault()">
                        <span>ÂêØÁî®ÈìæÊù°ÂØπËØùÔºàÈªòËÆ§Ôºâ</span>
                    </label>
                    <div style="font-size: 11px; color: #666; margin-top: 8px;">
                        ÂêØÁî®ÂêéÔºåÊØèÊ¨°ÂØπËØùÈÉΩ‰ºöÈÄöËøáÈÄâÂÆöÁöÑÈìæÊù°Ë∑ØÂæÑËøõË°åÂ§ÑÁêÜ
                    </div>
                </div>
            `;

            if (chainPathConfigs.length === 0) {
                html += '<div class="empty-state"><div class="empty-state-icon">üõ£Ô∏è</div><p>ËøòÊ≤°ÊúâÈìæÊù°Ë∑ØÂæÑ</p></div>';
            } else {
                chainPathConfigs.forEach(path => {
                    const isDefault = currentChainPathConfig?.id === path.id;

                    // ÊûÑÂª∫ÈìæÊù°Â∫èÂàóÔºåÂåÖÂê´ÊâßË°åÊ®°Âºè‰ø°ÊÅØ
                    let chainSequence = '';
                    if (path.chains && path.chains.length > 0) {
                        path.chains.forEach((id, idx) => {
                            const chain = chainManager.getChain(id);
                            const chainName = chain ? chain.name : `‚ùå ${id}`;

                            if (chainSequence) {
                                // ‰ΩøÁî®path.executionModes‰∏≠ÁöÑÂØπÂ∫îÈ°πÔºåÂ¶ÇÊûú‰∏çÂ≠òÂú®ÂàôÈªòËÆ§‰∏∫'sequential'
                                const mode = path.executionModes ? path.executionModes[idx - 1] : 'sequential';
                                const separator = mode === 'parallel' ? '//' : '->';
                                chainSequence += ` ${separator} `;
                            }
                            chainSequence += chainName;
                        });
                    }

                    html += `
                        <div class="config-item" style="border-left: 3px solid ${isDefault ? '#667eea' : '#ddd'}; ${isDefault ? 'background: #f0f7ff;' : ''}">
                            <div class="config-item-header">
                                <div class="config-item-name">
                                    ${isDefault ? '‚≠ê ' : ''}${path.name}
                                </div>
                                <div class="config-item-actions">
                                    ${!isDefault ? `<button class="config-btn-small" onclick="setDefaultChainPath('${path.id}')">ËÆæ‰∏∫ÈªòËÆ§</button>` : '<span style="color: #667eea; font-weight: bold;">Â∑≤ËÆæ‰∏∫ÈªòËÆ§</span>'}
                                    <button class="config-btn-small danger" onclick="deleteChainPath('${path.id}')">Âà†Èô§</button>
                                </div>
                            </div>
                            <div class="config-item-detail">Ë∑ØÂæÑ: ${chainSequence}</div>
                            <div class="config-item-detail">ÊèèËø∞: ${path.description || 'Êó†'}</div>
                            <div class="config-item-detail">‰ΩøÁî®Ê¨°Êï∞: ${path.useCount || 0}</div>
                        </div>
                    `;
                });
            }

            html += `
                <div class="config-form">
                    <h4 style="margin: 0 0 12px 0; font-size: 13px;">‚ûï ÂàõÂª∫Êñ∞ÈìæÊù°Ë∑ØÂæÑ</h4>
                    <div class="form-group">
                        <label class="form-label">Ë∑ØÂæÑÂêçÁß∞</label>
                        <input type="text" class="form-input" id="newPathName" placeholder="e.g., ‰ª£Á†ÅÂÆ°Êü•ÊµÅÁ®ã">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Ë∑ØÂæÑÊèèËø∞</label>
                        <input type="text" class="form-input" id="newPathDesc" placeholder="e.g., Áî®‰∫é‰ª£Á†ÅË¥®ÈáèÊ£ÄÊü•Âíå‰ºòÂåñ">
                    </div>
                    <div class="form-group">
                        <label class="form-label">ÈÄâÊã©ÈìæÊù°ÔºàÈ°∫Â∫èÂæàÈáçË¶ÅÔºâ</label>
                        <div id="chainPathSelector" style="display: flex; flex-wrap: wrap; gap: 8px; padding: 8px; background: #f9f9f9; border-radius: 4px; border: 1px dashed #ddd; min-height: 40px;">
                            <!-- Â∞ÜÂú®‰∏ãÈù¢Â°´ÂÖÖ -->
                        </div>
                        <div style="font-size: 11px; color: #999; margin-top: 6px;">
                            üí° ÊèêÁ§∫ÔºöÊîØÊåÅÈáçÂ§ç‰ΩøÁî®Áõ∏ÂêåÈìæÊù°ÔºåÂ¶Ç A-B-A Êàñ A-B-C-A
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Â∑≤ÈÄâÈìæÊù°</label>
                        <div id="selectedChainsList" style="display: flex; flex-wrap: wrap; gap: 6px; padding: 8px; background: #e8f0ff; border-radius: 4px; min-height: 35px;">
                            <span style="color: #999;">ÁÇπÂáª‰∏äÈù¢ÁöÑÈìæÊù°Ê∑ªÂä†</span>
                        </div>
                    </div>
                    <div class="form-buttons">
                        <button class="form-btn primary" onclick="addNewChainPath()">ÂàõÂª∫Ë∑ØÂæÑ</button>
                        <button class="form-btn secondary" onclick="clearSelectedChains()">Ê∏ÖÁ©∫ÈÄâÊã©</button>
                    </div>
                </div>
            `;

            section.innerHTML = html;
            
            // Â°´ÂÖÖÈìæÊù°ÈÄâÊã©Âô®
            const selector = document.getElementById('chainPathSelector');
            chainConfigs.forEach(chain => {
                const btn = document.createElement('button');
                btn.className = 'chain-selector-btn';
                btn.textContent = chain.name;
                btn.style.cssText = 'padding: 6px 10px; background: white; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.2s;';
                btn.onclick = () => addChainToPath(chain.id, chain.name);
                btn.onmouseover = () => { btn.style.background = '#667eea'; btn.style.color = 'white'; };
                btn.onmouseout = () => { btn.style.background = 'white'; btn.style.color = 'black'; };
                selector.appendChild(btn);
            });
        }

        let selectedChainPathList = [];

        // ÁîüÊàêÊâßË°åÂ∫èÂàóÊñáÊú¨ (Áî®‰∫éÊòæÁ§∫ A -> B // C -> D ÁöÑÊ†ºÂºè)
        function generateExecutionSequence(list) {
            if (list.length === 0) return '';
            let sequence = list[0].name;
            for (let i = 0; i < list.length - 1; i++) {
                const separator = list[i].modeToNext === 'parallel' ? '//' : '->';
                sequence += ` ${separator} ${list[i + 1].name}`;
            }
            return sequence;
        }

        function addChainToPath(chainId, chainName) {
            selectedChainPathList.push({
                id: chainId,
                name: chainName,
                modeToNext: 'sequential'  // ÈªòËÆ§‰∏é‰∏ã‰∏ÄÊù°ÈìæÊù°È°∫Â∫èÊâßË°å
            });
            updateSelectedChainsList();
        }

        // ÂàáÊç¢ÈìæÊù°ÁöÑÊâßË°åÊ®°Âºè
        function toggleChainExecutionMode(index) {
            if (index >= 0 && index < selectedChainPathList.length && index < selectedChainPathList.length - 1) {
                const current = selectedChainPathList[index];
                current.modeToNext = current.modeToNext === 'sequential' ? 'parallel' : 'sequential';
                updateSelectedChainsList();
            }
        }

        function removeChainFromPath(index) {
            selectedChainPathList.splice(index, 1);
            updateSelectedChainsList();
        }

        function updateSelectedChainsList() {
            const container = document.getElementById('selectedChainsList');
            if (selectedChainPathList.length === 0) {
                container.innerHTML = '<span style="color: #999;">ÁÇπÂáª‰∏äÈù¢ÁöÑÈìæÊù°Ê∑ªÂä†</span>';
                return;
            }

            // ÊòæÁ§∫ÊâßË°åÂ∫èÂàóÈ¢ÑËßà
            const sequence = generateExecutionSequence(selectedChainPathList);
            let html = `<div style="margin-bottom: 12px; padding: 8px; background: #f0f7ff; border-radius: 4px; border-left: 3px solid #667eea; font-size: 12px; color: #333;">
                <strong>ÊâßË°åÂ∫èÂàó:</strong> ${sequence}
            </div>`;

            // ÊòæÁ§∫ÊØè‰∏™ÈìæÊù°ÂèäÂÖ∂ÊâßË°åÊ®°ÂºèÊåâÈíÆ
            selectedChainPathList.forEach((item, idx) => {
                const modeButton = idx < selectedChainPathList.length - 1 ?
                    `<button onclick="toggleChainExecutionMode(${idx})" style="background: none; border: 1px solid #667eea; color: #667eea; padding: 2px 8px; border-radius: 3px; cursor: pointer; font-size: 11px; margin: 0 4px;">
                        ${item.modeToNext === 'sequential' ? '->' : '//'}
                    </button>` : '';

                html += `
                    <div style="display: flex; align-items: center; gap: 4px; background: white; padding: 4px 8px; border-radius: 4px; border: 1px solid #667eea; margin-bottom: 4px;">
                        <span>${item.name}</span>
                        ${modeButton}
                        <button onclick="removeChainFromPath(${idx})" style="background: none; border: none; color: #667eea; cursor: pointer; font-size: 14px; padding: 0 4px; margin-left: auto;">‚úï</button>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        function clearSelectedChains() {
            selectedChainPathList = [];
            updateSelectedChainsList();
        }

        function addNewChainPath() {
            const name = document.getElementById('newPathName').value.trim();
            const desc = document.getElementById('newPathDesc').value.trim();

            if (!name || selectedChainPathList.length === 0) {
                alert('ËØ∑Â°´ÂÜôË∑ØÂæÑÂêçÁß∞Âπ∂Ëá≥Â∞ëÈÄâÊã©‰∏ÄÊù°ÈìæÊù°');
                return;
            }

            const chainIds = selectedChainPathList.map(item => item.id);
            const executionModes = selectedChainPathList.map(item => item.modeToNext);

            chainPathBuilder.createPath({
                name,
                description: desc,
                chains: chainIds,
                executionModes: executionModes  // ‰º†ÈÄíÊâßË°åÊ®°Âºè
            });

            document.getElementById('newPathName').value = '';
            document.getElementById('newPathDesc').value = '';
            selectedChainPathList = [];
            renderChainPathsTab();
            showSaveIndicator('‚úì ÈìæÊù°Ë∑ØÂæÑÂ∑≤ÂàõÂª∫');
        }

        function setDefaultChainPath(pathId) {
            chainPathBuilder.setDefault(pathId);
            renderChainPathsTab();
            showSaveIndicator('‚úì ÈªòËÆ§Ë∑ØÂæÑÂ∑≤ËÆæÁΩÆ');
        }

        function deleteChainPath(pathId) {
            if (!confirm('Á°ÆÂÆöË¶ÅÂà†Èô§Ê≠§ÈìæÊù°Ë∑ØÂæÑÂêóÔºü')) return;
            chainPathBuilder.deletePath(pathId);
            if (currentChainPathConfig?.id === pathId) {
                currentChainPathConfig = null;
            }
            renderChainPathsTab();
            showSaveIndicator('‚úì ÈìæÊù°Ë∑ØÂæÑÂ∑≤Âà†Èô§');
        }

        function toggleChainByDefault() {
            executionSession.useChainByDefault = document.getElementById('useChainByDefault').checked;
            saveChainPathConfigurations();
            showSaveIndicator(`‚úì ÈìæÊù°ÂØπËØù${executionSession.useChainByDefault ? 'Â∑≤ÂêØÁî®' : 'Â∑≤Á¶ÅÁî®'}`);
        }

        // ========== Ê®°Âùó5ÔºöË∑ØÁî±ÁÆ°ÁêÜ ==========
        function renderRoutesTab() {
            const section = document.getElementById('routesSection');
            let html = '<h3>üìç Ë∑ØÁî±ÁÆ°ÁêÜ</h3>';

            if (routingRules.length === 0) {
                html += '<div class="empty-state"><div class="empty-state-icon">üì≠</div><p>ËøòÊ≤°ÊúâË∑ØÁî±</p></div>';
            } else {
                routingRules.forEach(route => {
                    const chainNames = route.chains.map(id => {
                        const chain = chainManager.getChain(id);
                        return chain ? chain.name : `‚ùå ${id}`;
                    }).join(' ‚Üí ');

                    html += `
                        <div class="config-item">
                            <div class="config-item-header">
                                <div class="config-item-name">${route.name}</div>
                                <div class="config-item-actions">
                                    <button class="config-btn-small" onclick="editRouteUI('${route.id}')">ÁºñËæë</button>
                                    <button class="config-btn-small danger" onclick="deleteRoute('${route.id}')">Âà†Èô§</button>
                                </div>
                            </div>
                            <table class="chain-info-table">
                                <tr><td>ID:</td><td>${route.id}</td></tr>
                                <tr><td>Ê®°Âºè:</td><td>${route.mode === 'sequential' ? 'È°∫Â∫èÊâßË°å' : route.mode === 'parallel' ? 'Âπ∂Ë°åÊâßË°å' : 'Ê†ëÂΩ¢ÊâßË°å'}</td></tr>
                                <tr><td>Áä∂ÊÄÅ:</td><td>${route.enabled ? '‚úì ÂêØÁî®' : '‚úó Á¶ÅÁî®'}</td></tr>
                                <tr><td>ÈìæÊù°:</td><td>${chainNames}</td></tr>
                            </table>
                        </div>
                    `;
                });
            }

            html += `
                <div class="config-form">
                    <h4 style="margin: 0 0 12px 0; font-size: 13px;">‚ûï ÂàõÂª∫Êñ∞Ë∑ØÁî±</h4>
                    <div class="form-group">
                        <label class="form-label">Ë∑ØÁî±ÂêçÁß∞</label>
                        <input type="text" class="form-input" id="newRouteName" placeholder="e.g., ‰ª£Á†ÅËØÑÂÆ°ÊµÅÁ®ã">
                    </div>
                    <div class="form-group">
                        <label class="form-label">ÊâßË°åÊ®°Âºè</label>
                        <select class="form-input" id="newRouteMode">
                            <option value="sequential">È°∫Â∫èÊâßË°å (A ‚Üí B ‚Üí C)</option>
                            <option value="parallel">Âπ∂Ë°åÊâßË°å (A // B // C)</option>
                            <option value="branching">Ê†ëÂΩ¢ÊâßË°å (A ‚Üí {B, C})</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">ËØ¥Êòé</label>
                        <p style="font-size: 11px; color: #999; margin: 6px 0;">
                            Âú®ÊéßÂà∂Âè∞‰ΩøÁî®ÔºöcreateNewRoute('Ë∑ØÁî±Âêç', ['chain_id1', 'chain_id2'], 'ÊâßË°åÊ®°Âºè')
                        </p>
                    </div>
                    <div class="form-buttons">
                        <button class="form-btn secondary" onclick="alert('ËØ∑‰ΩøÁî®ÊéßÂà∂Âè∞ÂàõÂª∫Ë∑ØÁî±Ôºö\\ncreateNewRoute(\\'Ë∑ØÁî±Âêç\\', [\\'chain_id1\\', \\'chain_id2\\'], \\'sequential\\')')">ÂàõÂª∫Ë∑ØÁî±</button>
                    </div>
                </div>
            `;

            section.innerHTML = html;
        }

        function deleteRoute(routeId) {
            if (!confirm('Á°ÆÂÆöË¶ÅÂà†Èô§Ê≠§Ë∑ØÁî±ÂêóÔºü')) return;
            routingManager.deleteRoute(routeId);
            renderRoutesTab();
            showSaveIndicator('‚úì Ë∑ØÁî±Â∑≤Âà†Èô§');
        }

        // ========== Phase 2: ÈìæÊù°ÊâßË°åÈù¢Êùø UI ==========

        function toggleExecutionPanel() {
            const panel = document.getElementById('executionPanel');
            panel.classList.toggle('active');
            if (panel.classList.contains('active')) {
                renderExecutionPanel();
            }
        }

        function closeExecutionPanel() {
            document.getElementById('executionPanel').classList.remove('active');
        }

        function renderExecutionPanel() {
            if (chainConfigs.length === 0) {
                alert('ËØ∑ÂÖàÂàõÂª∫ÈìæÊù°');
                return;
            }

            // Ê∏≤ÊüìÈìæÊù°ÈÄâÊã©Âô®
            const container = document.getElementById('chainSelectorContainer');
            let html = '';

            chainConfigs.forEach(chain => {
                const isSelected = executionSession.selectedChains.includes(chain.id);
                html += `
                    <button class="chain-toggle ${isSelected ? 'selected' : ''}"
                            onclick="toggleChainSelection('${chain.id}')">
                        ${chain.name}
                    </button>
                `;
            });

            container.innerHTML = html;

            // Êõ¥Êñ∞ÊµÅÁ®ãÂõæ
            updateFlowDiagram();
        }

        function toggleChainSelection(chainId) {
            const index = executionSession.selectedChains.indexOf(chainId);
            if (index > -1) {
                executionSession.selectedChains.splice(index, 1);
            } else {
                executionSession.selectedChains.push(chainId);
            }

            renderExecutionPanel();
        }

        function selectExecutionMode(mode) {
            executionSession.mode = mode;

            // Êõ¥Êñ∞ÊåâÈíÆÁä∂ÊÄÅ
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            event.target.closest('.mode-btn').classList.add('selected');

            updateFlowDiagram();
        }

        function updateFlowDiagram() {
            const diagram = document.getElementById('executionFlowDiagram');

            if (executionSession.selectedChains.length === 0) {
                diagram.textContent = '- ÈÄâÊã©ÈìæÊù°ÂêéÊòæÁ§∫ÊâßË°åÊµÅÁ®ã -';
                return;
            }

            let flow = '';
            const chainNames = executionSession.selectedChains.map(id => {
                const chain = chainManager.getChain(id);
                return chain ? chain.name : id;
            });

            if (executionSession.mode === 'sequential') {
                flow = chainNames.join(' ‚Üí ');
            } else if (executionSession.mode === 'parallel') {
                flow = chainNames.join(' // ');
            } else if (executionSession.mode === 'branching') {
                flow = `${chainNames[0]} ‚Üí {${chainNames.slice(1).join(', ')}}`;
            }

            diagram.textContent = flow;
        }

        async function executeRoute() {
            if (executionSession.selectedChains.length === 0) {
                alert('ËØ∑ÈÄâÊã©Ëá≥Â∞ë‰∏Ä‰∏™ÈìæÊù°');
                return;
            }

            if (isGenerating || executionSession.isExecuting) {
                alert('ÊúâÂÖ∂‰ªñ‰ªªÂä°Ê≠£Âú®ÊâßË°å...');
                return;
            }

            const userMessage = userInput.value.trim();
            if (!userMessage) {
                alert('ËØ∑ËæìÂÖ•Áî®Êà∑Ê∂àÊÅØ');
                return;
            }

            executionSession.isExecuting = true;
            const resultContainer = document.getElementById('executionResultContainer');
            resultContainer.innerHTML = '<div class="execution-result"><div class="execution-result-title">‚è≥ Ê≠£Âú®ÊâßË°å...</div></div>';

            try {
                const results = await dialogueExecutor.execute(
                    executionSession.mode,
                    executionSession.selectedChains,
                    userMessage
                );

                displayExecutionResults(results);
                executionSession.results = results;

                // ÂêåÊó∂Âú®ËÅäÂ§©Ê°Ü‰∏≠ÊòæÁ§∫ÁªìÊûú
                displayExecutionInChat(results);

            } catch (error) {
                console.error('ÊâßË°åÈîôËØØ:', error);
                resultContainer.innerHTML = `
                    <div class="execution-result">
                        <div class="execution-result-title">‚ùå ÊâßË°åÂ§±Ë¥•</div>
                        <div class="execution-result-item error">${error.message}</div>
                    </div>
                `;
            } finally {
                executionSession.isExecuting = false;
            }
        }

        function displayExecutionResults(results) {
            const container = document.getElementById('executionResultContainer');
            let html = '<div class="execution-result">';
            html += '<div class="execution-result-title">‚úÖ ÊâßË°åÂÆåÊàê</div>';

            const successCount = results.filter(r => r.success).length;
            const failCount = results.filter(r => !r.success).length;

            results.forEach((result, idx) => {
                if (result.success) {
                    html += `
                        <div class="execution-result-item chain-result">
                            <div class="chain-execution-label">${idx + 1}. ${result.chainName}</div>
                            <div class="chain-execution-text">${result.response.substring(0, 200)}${result.response.length > 200 ? '...' : ''}</div>
                        </div>
                    `;
                } else {
                    html += `
                        <div class="execution-result-item error">
                            <div class="chain-execution-label">‚ùå ${result.chainName || 'Êú™Áü•'}</div>
                            <div class="chain-execution-text">${result.error || 'Êú™Áü•ÈîôËØØ'}</div>
                        </div>
                    `;
                }
            });

            html += `
                <div class="execution-stats">
                    <div class="stat-item">
                        <div class="stat-value">${successCount}</div>
                        <div class="stat-label">ÊàêÂäü</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${failCount}</div>
                        <div class="stat-label">Â§±Ë¥•</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${results.length}</div>
                        <div class="stat-label">ÊÄªËÆ°</div>
                    </div>
                </div>
            `;

            html += '</div>';
            container.innerHTML = html;
        }

        function displayExecutionInChat(results) {
            // Âú®ËÅäÂ§©Ê°Ü‰∏≠ÊòæÁ§∫ÂÆåÊï¥ÁöÑÊâßË°åÁªìÊûú
            const wrapper = document.createElement('div');
            wrapper.className = 'message-wrapper';

            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'message-content-wrapper';

            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ai';

            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';

            let text = 'üîó ÈìæÊù°ÊâßË°åÁªìÊûú\n';
            text += '‚îÅ'.repeat(30) + '\n';

            results.forEach((result, idx) => {
                if (result.success) {
                    text += `\n[${idx + 1}] ${result.chainName}:\n`;
                    text += result.response + '\n';
                } else {
                    text += `\n[‚ùå] ${result.chainName}: ${result.error}\n`;
                }
            });

            contentDiv.textContent = text;
            messageDiv.appendChild(contentDiv);
            contentWrapper.appendChild(messageDiv);
            wrapper.appendChild(contentWrapper);

            chatBox.appendChild(wrapper);
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        function saveAsRoute() {
            if (executionSession.selectedChains.length === 0) {
                alert('ËØ∑ÈÄâÊã©Ëá≥Â∞ë‰∏Ä‰∏™ÈìæÊù°');
                return;
            }

            const routeName = prompt('ËæìÂÖ•Ë∑ØÁî±ÂêçÁß∞:');
            if (!routeName) return;

            createNewRoute(routeName, executionSession.selectedChains, executionSession.mode);
            showSaveIndicator('‚úì Ë∑ØÁî±Â∑≤‰øùÂ≠ò');
        }

        // ========== Â§öÈìæÊù°Á≥ªÁªüÁöÑÊéßÂà∂Âè∞ÂáΩÊï∞ ==========
        function viewChains() {
            console.log('=== ÊâÄÊúâÈìæÊù° ===');
            chainConfigs.forEach((chain, idx) => {
                const model = configManager.getModel(chain.modelId);
                const prompt = configManager.getPrompt(chain.promptId);
                const memory = configManager.getMemoryDB(chain.memoryDBId);
                console.log(`${idx + 1}. ${chain.name} (${chain.id})`);
                console.log(`   Ê®°Âûã: ${model ? model.name : 'Êú™ÊâæÂà∞'}`);
                console.log(`   ÊèêÁ§∫ËØç: ${prompt ? prompt.name : 'Êú™ÊâæÂà∞'}`);
                console.log(`   ËÆ∞ÂøÜÂ∫ì: ${memory ? memory.name : 'Êú™ÊâæÂà∞'}`);
                console.log(`   ËøûÊé•Âà∞: ${chain.connections.length > 0 ? chain.connections.join(', ') : 'Êó†'}`);
                console.log('   ---');
            });
        }

        function viewRoutes() {
            console.log('=== ÊâÄÊúâË∑ØÁî± ===');
            routingRules.forEach((route, idx) => {
                console.log(`${idx + 1}. ${route.name} (${route.id})`);
                console.log(`   ÊâßË°åÊ®°Âºè: ${route.mode}`);
                console.log(`   ÈìæÊù°: ${route.chains.join(' ‚Üí ')}`);
                console.log(`   ÂêØÁî®: ${route.enabled ? 'ÊòØ' : 'Âê¶'}`);
                console.log('   ---');
            });
        }

        function createNewChain(name, modelId, promptId, memoryDBId) {
            const chainId = `chain_${Date.now()}`;
            const chain = chainManager.createChain({
                id: chainId,
                name,
                modelId,
                promptId,
                memoryDBId,
                parameters: {
                    temperature: 0.7,
                    top_p: 0.9,
                    top_k: 40,
                    repeat_penalty: 1.1
                }
            });
            console.log(`‚úÖ ÂàõÂª∫ÈìæÊù°: ${chain.name}`);
            return chain;
        }

        function createNewRoute(name, chainIds, mode = 'sequential') {
            const routeId = `route_${Date.now()}`;
            const route = routingManager.createRoute({
                id: routeId,
                name,
                chains: chainIds,
                mode
            });
            console.log(`‚úÖ ÂàõÂª∫Ë∑ØÁî±: ${route.name}`);
            return route;
        }

        function linkChains(sourceChainId, targetChainId) {
            chainManager.connectChains(sourceChainId, targetChainId);
            console.log(`‚úÖ Â∑≤ËøûÊé•: ${sourceChainId} ‚Üí ${targetChainId}`);
        }

        function showChainInfo(chainId) {
            const chain = chainManager.getChain(chainId);
            if (!chain) {
                console.log('‚ùå ÈìæÊù°‰∏çÂ≠òÂú®');
                return;
            }
            const model = configManager.getModel(chain.modelId);
            const prompt = configManager.getPrompt(chain.promptId);
            const memory = configManager.getMemoryDB(chain.memoryDBId);

            console.log(`\n${'='.repeat(40)}`);
            console.log(`ÈìæÊù°: ${chain.name} (${chain.id})`);
            console.log(`${'='.repeat(40)}`);
            console.log(`Ê®°Âûã: ${model ? model.name : 'Êú™ÊâæÂà∞'}`);
            console.log(`ÊèêÁ§∫ËØç: ${prompt ? prompt.name : 'Êú™ÊâæÂà∞'}`);
            console.log(`ËÆ∞ÂøÜÂ∫ì: ${memory ? memory.name : 'Êú™ÊâæÂà∞'}`);
            console.log(`ËøûÊé•Âà∞: ${chain.connections.length > 0 ? chain.connections.join(', ') : 'Êó†'}`);
            console.log(`Ë∞ÉÁî®Ê¨°Êï∞: ${chain.statistics.invocations}`);
            console.log(`ÂèÇÊï∞: `, chain.parameters);
            console.log(`${'='.repeat(40)}\n`);
        }

        // ========== ÂêØÂä®Â∫îÁî® ==========
        init();
        updateVectorDBInfo();
        userInput.focus();
    </script>
</body>
</html>
